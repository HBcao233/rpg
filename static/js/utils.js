// 物品
const items = {
  'coin': {
    name: '金币',
    icon: 'coin1',
    color: 'coin',
    background: 'common',
    caption: '咔～磬～',
    desc: '这个世界的基本货币。你可以通过击败敌人、随机事件和打开宝箱获得金币。你可以用金钱从商人处购买商品，或是购买牧师的服务，还可以用于贿赂。\n无法在战斗中使用。',
    use: [],
  },
  'cum': {
    name: '精液瓶',
    icon: 'mp_potion',
    color: '',
    background: 'common',
    caption: '我没有找到保险套的图标qwq',
    desc: '被装在橡胶容器里的精液\n白浊法师的特殊道具。她们每次攻击的时候都需要消耗一个 精液瓶。\n她们可以从敌人或自己的身体中获取新的精液瓶。',
    use: [],
  },
  'honey': {
    name: '黏稠蜂蜜',
    icon: 'hp_potion',
    color: '',
    background: 'common',
    caption: '',
    desc: '这是从能产生媚药的植物花粉中精炼出的蜂蜜。\n它非常地黏，所以你可以用它来拖慢敌人的速度。你也可以喝下它，恢复自己HP，但自己会微微发情。',
    use: [
      {
        name: '你将它扔向敌人',
        effect: '敌人骰子点数减少1点',
        task: '如果敌人的攻击需要你用到润滑液，在你的润滑液中混入部分蜂蜜。',
      },
      {
        name: '你喝下了它',
        effect: '回复5点生命值',
        task: '喝下10mL蜂蜜。你下一回合的bpm将増加20点。',
      },
    ],
  },
  'philter': {
    name: '浓缩媚药',
    icon: 'hp_potion',
    color: '',
    background: 'common',
    caption: '只需一滴，让你像水龙头一样射个不停，呵呵～',
    desc: '从产生媚药的植物中提取的媚药精华。\n从产生媚药的植物中提取的媚药精华。',
    use: [
      {
        name: '你将它扔向敌人',
        effect: '敌人受到3点伤害',
        task: '下个回合敌人的骰子点数 +2，且你受到的伤害增加1点。',
      },
    ],
  },
  'scroll_climax': {
    name: '绝顶卷轴',
    icon: 'scroll',
    color: 'uncommon',
    background: 'scroll1',
    caption: '咿...!去了...!!',
    desc: '会让使用者立即高潮的卷轴。\n基本效果就是立刻让你高潮一次，即使你被锁在贞操带中。它可以在任何时候被使用。',
    use: [
      {
        name: '你使用了它',
        effect: 'HP减少3点',
        task: '你可以暂时移除你的贞操带。你有5分钟的时间来让自己绝顶。\n你必须完全绝顶: 直至射精完全结束，你都不可以停止或减少刺激的力度。若你在战斗中使用，绝顶后对敌人造成5点伤害。',
      },
    ],
  },
  'scroll_': {
    name: '符文卷轴: 淫',
    icon: 'scroll',
    color: '',
    background: 'scroll2',
    caption: '',
    desc: '记载了用于增强自己能力的淫荡文字的卷轴。\n它可以在任何时侯被使用。',
    use: [
      {
        name: '你使用了它',
        effect: '你造成的伤害提高1点',
        task: '你必须用红色记号笔在你的身体上写下大大的“淫荡[你的种族名]”几个字。只要它没被擦除，此效果就可以一直起作用。',
      },
    ],
  },
  'herb': {
    name: '镇静草药',
    icon: 'herb',
    color: '',
    background: 'common',
    caption: '暴风吸入吧!我的英雄!',
    desc: '一种可以用来做成饮料的草药。当它被酿成酒后，即使是重度发情的冒险者也会冷静下来。\n你可以直接咀嚼它来回复一些HP。\n你可以在任何时候使用它。',
    use: [
      {
        name: '你把它放进了嘴里',
        effect: '你的HP回复8点',
        task: '在你的下一顿饭中加入蔬莱沙拉',
      },
    ],
  },
  'wine': {
    name: '镇静之酒',
    icon: 'hp_potion',
    color: 'uncommon',
    background: 'uncommon',
    caption: '',
    desc: '用镇静药草和糖酿制的美酒\n当你持有3个镇静药草时，你可以花费一个格子的时间，将其合成为此物品。\n喝下镇静之酒可以消除一层<span class="color_curse">诅咒</span>。\n你可以在任何时侯使用它。',
    use: [
      {
        name: '你喝下了瓶中的液体',
        effect: '你的某个<span class="color_curse">诅咒</span>减少了一层。',
        task: '喝下一小杯带酒精饮料。并且你的下三个回合的bpm减少30点。',
      }
    ],
  },
  'juice': {
    name: '恢复药水',
    icon: 'hp_potion',
    color: '',
    background: 'common',
    caption: '其实基本就是果汁。',
    desc: '炼金术师们大量生产的药水，效果一般。\n可以恢复HP，没别的效果。你在可以任何时候使用它。',
    use: [
      {
        name: '你喝下了它',
        effect: '你的HP恢复3点。',
        task: '喝一小杯果汁。',
      }
    ],
  },
  'milk': {
    name: '荷斯陶洛斯牛奶',
    icon: 'mp_potion',
    color: 'uncommon',
    background: 'uncommon',
    caption: '嗯～下次尝尝雄性荷斯陶洛斯的牛奶吧～',
    desc: '<a class="link" href="https://zhmonstergirlencyclopedia.miraheze.org/wiki/荷斯陶洛斯">荷斯陶洛斯</a>乳房中榨出的牛奶。它可以恢复你的生命值。用下面的嘴喝吸收更快。任何时候均可使用。',
    use: [
      {
        name: '你喝下了牛奶',
        effect: '你的HP恢复5点。',
        task: '喝下 200mL 牛奶。',
      },
      {
        name: '你决定让它吸收更快',
        effect: '你的HP恢复10点。',
        task: '将200mL牛奶注入后穴。然后你必须正常地做其他任务。80分钟后将其排出。',
      },
    ],
  },
  'spring': {
    name: '圣泉药剂',
    icon: 'spring_potion',
    color: '',
    background: 'epic',
    caption: '',
    desc: '从分布在世界各名处的圣泉中提取的药剂。\n圣泉药剂只可以通过直肠给药。它可以治愈你屁股里被施加的<span class="color_curse">诅咒</span>。你可以在任何时候使用它。',
    use: [
      {
        name: '你将药水全部注入了你的菊穴',
        effect: '你的诅咒减少了。',
        task: '将 1000mL 水注入直肠。你需要等待30分钟来吸收药剂的效果。期间你可以短暂地休息。之后你可以去除一层<span class="color_curse">[肉穴酸痛]</span>或 <span class="color_curse">[体内受精]</span>。若你提前排出了药水，则药水不会起作用。',
      },
    ],
  },
  'jerky': {
    name: '绿兽人的肉干',
    icon: 'jerky',
    color: '',
    background: 'uncommon',
    caption: '呕～那个绿兽人平时都把这玩意藏在哪啊!',
    desc: '绿兽人爱吃的内干。由未知动物制成。\n在战斗中食用此肉干，你的下一次攻击将必定打出高额伤害。',
    use: [
      {
        name: '你勉强将其吞下',
        effect: '你的下次攻击将必定为</span class="color_key">[会心]</span>。',
        task: '吃下一块肉干或者其他零食。食用前必须充分地用你的肉棒给零食添加味道，并且蘸上精液食用。',
      }
    ],
  },
  'slave_key': {
    name: '奴隶钥匙',
    icon: 'key1',
    color: '',
    background: 'epic',
    caption: '你真是一个不听话的奴隶。',
    desc: '能解开强盗给你套上的枷锁和项圈的钥匙。\n使用它将解放你被施加的奴隶诅咒。你可以在任何时候使用。',
    use: [
      {
        name: '你使用了钥匙',
        effect: '你的诅咒减少了',
        task: '减少一层<span class="color_curse">[奴隶标记]</span>的效果。',
      }
    ],
  },
  'rope': {
    name: '逃生绳',
    icon: 'rope',
    color: '',
    background: 'uncommon',
    caption: '它能保护你的后庭!',
    desc: '魔法物品。能让你传送至安全地点。\n使用后你将立刻脱离当前的战斗。你不会得到任何战斗奖励。只能在战斗中使用。',
    use: [
      {
        name: '你发动了传送魔法',
        effect: '你逃跑了。',
        task: '立刻结東当前的战斗。',
      }
    ],
  },
  'chest_key': {
    name: '宝箱钥匙',
    icon: 'key2',
    color: '',
    background: 'epic',
    caption: '好好搜刮宝箱里的物品吧!',
    desc: '魔法道具。能够打开任意宝箱的钥匙。\n但是它的魔カ很弱，使用一次后就失效了。',
    use: [],
  },
  'godness_dice': {
    name: '女神的骰子',
    icon: 'dice',
    color: 'uncommon',
    background: 'epic',
    caption: '喂!你不能用那个!那是我的!',
    desc: '轮盘之神的力量之源之一。你可以用它来操作随机之カ的效果。\n投掷女神的骰子可以重置你的命运。你可以在任何需要投掷般子的场合使用它。<span class="color_skill">[可重复使用]</span>。',
    use: [
      {
        name: '你投出了骰子',
        effect: '你的命运改变了',
        task: '使用新骰子的点数覆盖你原来的点数。你只可以对每个骰子使用一次。你必须接受你新的命运!',
      },
    ],
  },
  'herb2': {
    name: '净化草',
    icon: 'herb2',
    color: '',
    background: 'uncommon',
    caption: '你为什么要使用它呢？你很享受被侵犯的对吧～',
    desc: '上面长着蓝色小花的药草。它能抑制媚药的效果。\n使用净化草后将暂时屏蔽你任何来源的bpm增加或是时间延长的负面效果。包括你的种族被动和诅咒。你只能在战斗中使用净化草。',
    use: [
      {
        name: '你嚼碎了药草',
        effect: '你的负面状态暂时消除了',
        task: '在当前战斗中，你不需要增加任何的bpm或是延长任何任务的时间。',
      }
    ],
  },
  'lucky_amulet': {
    name: '幸运护身符',
    icon: 'amulet',
    color: 'uncommon',
    background: 'epic',
    caption: '啊啊啊啊～～快把这个给我啊啊～～～',
    desc: '能够增加你幸运值的项链。\n在战斗中触发它的效果可以保证你打出会心攻击。但是它的影响范围太广了所以你的敌人也会得到增强。\n每场战斗只能使用一次。<span class="color_skill">[可重复使用]</span>。',
    use: [
      {
        name: '你使用了护身符',
        effect: '温暖的力量从你身体中散发出来',
        task: '你和你的敌人的下次攻击将心必定为 <span class="color_key">[会心]</span>。',
      },
    ],
  },
};
// 敌人种族
const enemy_races = {
  'human': {
    name: '人类',
    desc: '像是普通的强盗、暴徒、盗贼等。他们大多数的人的工作就是在各个城市中拐卖奴隶，新手冒险者和弱小的旅行者是他们的头号目标。你若不幸被他们捕获，他们会将奴隶的身份证明标记在你身上，并且将你售往下一个人类的村庄或城市。',
    curse: 'slave',
  },
  'beast': {
    name: '野兽',
    desc: '他们是由各种名样充满野性的动物和其他野兽组成的敌人。在新规则的影响下，他们的性欲大大增强，并通常会发泄至旅行者的身上。他们的耐久力是如此之强，要是披他们打败，保证你的肉穴会酸痛好几天。',
    curse: 'beast',
  },
  'tentacle': {
    name: '触手',
    desc: '它们是会利用陷阱将冒险者们捕获，然后寄生在她们身上的敌人。很多触手类怪物都是源于植物的，所以他们分泌的用于润滑的汁液里通常含有媚药或者成瘾性成分。很多时候触手们骚扰过一次冒险者后就让她们离开，殊不知己经悄悄寄生在她们体内深处。',
    curse: 'tentacle',
  },
  'enchanter': {
    name: '魔法师',
    desc: '她们是由各种法师和术士还有巫师组成的群体，寻找着可以用来控制/的傀儡和奴隶。她们将淫秽的诅咒施加给旅行老们，直到她们因欲望而崩溃。这样就可以拿发狂的冒险者们当做无尽的魔力供应源来使用了。',
    curse: 'enchanter',
  },
  'orcish': {
    name: '绿兽人',
    desc: '绿兽人通常会组成部落分布于这个大地上。由于他们身形强壮，恶魔领主的新规则将他们转化成了这个世界中的顶级性爱战士。现在，绿兽人们正四处抓捕冒险者，将他们囚禁在村庄内作为“牲口”或者性爱玩具来便用。',
    curse: 'orcish',
  },
  'insect': {
    name: '昆虫',
    desc: '它们外貌各异，可能是巨大的野生昆虫也可能是高级的人形魔物。在新规则的影响下，它们无法与自己的同类交配，只能通过让冒险者们受精，从而让她们产下自己的卵来繁殖后代。如果你一直被昆虫族受精产卵的话，它们体内的毒素和媚药会慢慢让你对此上瘾。',
    curse: 'insect',
  },
}
// 诅咒
const curses = {
  'slave': {
    name: '奴隶印记',
    levels: [
      {
        name: '戴上项圈',
        desc: '你醒了，发现自己的脖子上被套上了一个项圈。你努カ地撕着它，但是不管怎样项圈都牢牢地锁在你的脖子上。你感到身体很不舒服，你意识到在你晕过去的那段时间里，那些人可能对你做了些什么......',
        task: '在你死亡前，你必须在脖子上佩戴一个项圈。以 100 bom的速度和敌人大小的肉棒操你的后庭5分钟，并且在完成后灌入 50mL 精液。',
      },
      {
        name: '戴上口球',
        desc: '你又醒了，发现你被敌人强制戴上了一个口球。你无法控制你的口水不停地往外滴，而说不出话来。',
        task: '在你死亡前，你必须佩戴口球。你无法购买道具以及无法从牧师处得到服务。',
      },
      {
        name: '永久烙印',
        desc: '你的敌人往你大腿内侧上烙下了一个特殊的符文，让你无法对也们的命令做出任何的反坑。若你再次被他们抓住，你将获得一个坏结局。',
        task: '在你大腿内侧写上奴隶两个大字，并且画一个带翅膀的爱心。当你的后庭或是口穴被玩弄时，必须大声呻吟。',
      },
      {
        name: '捆绑销售',
        desc: '你彻底向他们屈服了。你接受了自己变成人类的奴隶的命运，即将被卖给下一个主人，为了让你再也没法逃跑，他们给你上了一个特别的项圈，这个项圈又是项圈又是口球，在面朝你的那边的内侧上有一根阳具。你的新生活是不断地被在各个城镇之间转送着，口穴和性器被持续地刺激，以便当你的主人拿到你的时候，身体各个部位已经被开发到位，你顺从于把你做性奴隶的主人，永远地服侍于他......',
        task: '为你的新生活做好准备。购买一个肉棒口球和用于捆绑的绳子，并学习如何龟甲缚或者其他紧缚。当你准备好后，戴上肉口球和龟甲缚，在你的后庭插入震动棒，肉棒上绑上跳蛋。在你的房间中准备好一条30米长用于爬行的路径。你的双脚需被捆在一起并与一个约20千克的重物连接。双手简单地反绑在背后(务必在自缚时确保你能迷脱，并准备安全剪刀)。你需在80分钟内爬完30米。若你超时、中途震动棒或是跳蛋脱落即视为任务失败，狠狠地扇你的屁股和生殖器分别20下，并且新开始任务直到你完成为止，在完成任务后在不解开束缚的情况下想办法让自己绝顶。',
      },
    ]
  },
  'enemy_beast': {
    name: '肉穴酸痛',
    levels: [
      {
        name: '轻度扩张',
        desc: '在你输掉战斗的几个小时后你醒来了，同时感到了自己后庭传來的隐隐作痛。你在昏厥的时间里，那只野兽肯定狠狠地操了你一顿。它那有倒刺的肉棒让你的菊穴酸胀。',
        task: '使用一根中等大小的自慰棒（最好是怪物形状）以 120bpm 的速度抽插10分钟。之后在你的穴内注入 50mL 精液。从现在开始，你每次将自慰棒插入之前，都需要在其表面涂上一层酒精。',
      },
      {
        name: '中度痛感',
        desc: '在另一只野兽对你发动攻击后，你又晕倒了，还好没有被他们抓住。你感觉你的后穴又变得更加松垮和酸痛了。同时你也感觉你更加像一只野兽了，甚至似乎出现了发情期...',
        task: '使用一根大号自慰棒 （最好是带凸起，怪物或马形状）以 100bpm 的速度柚插 10分钟。之后在你的穴内注入 100mL 精液。从现在开始，所有插入你的肉棒的尺寸将増大ー个等级。',
      },
      {
        name: '酸胀难忍',
        desc: '再次从晕厥中醒来后，你发下你的后庭似乎正在渴望着被野兽的内棒更强烈的侵犯。他们对你施加的效果是永久的，你开始对野兽的气味上瘾，再次败北的话你将失去作为自我的本能。',
        task: '所有的插入类任务的bpm将增大20点，并且插入前需要在自慰棒上滴上一滴风油精。从现在起，每走过三个格子，你需要一边骑在上述描述的肉棒上一边寸止一次。',
      },
      {
        name: '兽嫁者',
        desc: '你已经完全臣服于野兽的肉棒之下。只有它们能满足你的后穴，你也正在从他们怪异的肉棒带来的痛感中获得快感，现在决定住在他们的巢穴里，得自己身体用于给他们产下后代，你悠闲的新生活就这样开始了，白天像个婊子，晚上被操个不停，你会侍奉他们的肉棒直到永远......',
        task: '购买一个狗或者马型的大号自慰棒。准备一些特制的精液，在其中加入一定量的酒精和盐 （如果你不对酒精过敏），从现在开始的五天里，将肉棒因定在墙上，每天你都要侍奉这根肉棒。每天早上给其口交5分钟，并且尝试深喉至少8次。口交过程中寸止一次，并在完成后饮下 30mL 加热过的精液，咽下过程中再寸止一次。每天晚上让肉棒以 60-120 bpm 逐渐增快的速度操你10分钟，期间必须寸止一次。在你被侵犯完毕后，试着将肉棒完全插入你的体内，在从你的体内拔出肉棒之前你必须绝顶一次。',
      },
    ]
  },
  'tentacle': {
    name: '触手寄生',
    levels: [
      {
        name: '早期症状',
        desc: '在一场激烈的战斗过后，你晕了过去。触手们慢慢缠上了你的身体，那成为了你记忆中里的最后一件事......后来那些生物夺迹般的释放了你，你没有多想，继续踏上征程。有时候你感到身体有些不对劲，但是耸肩无视。',
        task: '从现在开始，你需要保证你的后穴得到充分地润滑。在任何使用润滑液的时候，使用双倍的剂量。你还需要将一颗跳蛋绑在你的肉棒上，但是要假装它不存在一样。',
      },
      {
        name: '体征改变',
        desc: '你又输掉了战斗。那些触手怪物再一次将你包赛，且往你的身体里注入了激素。你醒来后发现自己的衣服都黏滑湿透了，你终于意识到自己被寄生了，但是你依然选择无视了它。',
        task: '在你的乳头上固定两枚跳蛋，并且准备三小碗煮过的并与润滑液混合均匀的面条（可以选购可食用润滑液或假精液以免浪费食物）。将其中两碗加入你的胸罩或是内衣中，剩下一碗加入你的内裤。',
      },
      {
        name: '深入骨髓',
        desc: '触手已经完全感染了你的肉体并开始在你的体内发育。那些生物释放了你，让你成为传播感染的媒介。如果你再次输给触手，触手们会侵入你的脑部，你的意识将触手的集群意识替换。',
        task: '从现在起，你所有的播入任务的bpm将增加20。当你不使用你的后穴时，必须插着一根中等大小的自慰棒。',
      },
      {
        name: '触手共生',
        desc: '触手们终于将你的身体同化为它们的一部分，包裹在你身体最外层的触手转化成了你衣服的样子，以不让其他人发现你的残酷命运。寄生已经将你的身体改造，你再也无法离开触手给你带来的快惑，你向这个事实妥协，配合着它们在城镇中传播附手的后代。作为汇报，它们消耗了你的排泄物，并且向你施加着永不结束的快感，你的大脑最终也将被登食殆尽，最后论为一具触手的空壳。',
        task: '准备一些紧身衣和一条紧身乳胶内裤，最好是泳衣或者其他防水服装（死库水），衣物的尺码需要比你平时穿的小一到两号。准备一大盆煮熟的有韧劲的面条，并与大量润滑液混合，在你的乳头和肉棒上因定好跳蛋后，穿上衣物，并且在你的衣物能覆盖到的所有地方加入面条。确保你的衣足够紧以至于面条都要被挤出来为止，在衣物的开口处做好密封以防漏出来太多，之后在你的紧紧身衣之上穿上正常衣物，然后穿着此胜手服在室外待一小时。任务完成后，隔着自己的衣物让自己绝顶，这就是你四处传播寄生的新生活。',
      },
    ]
  },
  'enchanter': {
    name: '淫纹刻印',
    levels: [
      {
        name: '精液熟成',
        desc: '在你输给一个法师之后醒来时，发现自己的小腹上多了一个奇怪的图案......你被刻上了一个封印淫纹! 魔法师们为了获得更加优质的浓厚精液封印了你的射精。现在你的生殖器被一个魔法贞操带给锁住了。',
        task: '在你的小腹上画一个中等大小的心型淫纹。当你被施加这个封印时，你必须「强制」佩戴贞操带并且不可以使用行何震动玩具刺激你的内棒。你所有涉及到肉棒的任务都变为后庭任务。寸止任务变为以150 bpm欺负你的后庭。',
      },
      {
        name: '感度上异',
        desc: '你醒来后感觉到身体很奇怪，惊恐地发现自己又被施加上了更多的淫纹。你一开始并不知道新的淫纹是什么效果但是......你很块意识到你的敏感度变得十分奇怪。这个恶魔般的印记让被刻上的肉体持续地遭受高感度的痛苦，或是快乐。',
        task: '将你小腹上的淫纹升级，画上翅膀符号以及其他更复杂的装饰。当你被施加这个淫纹时，你必须将所有肉棒的尺寸增大一个等级。你从任何来源受到的伤害增加1点。',
      },
      {
        name: '永久发情',
        desc: '你又披打了，魔法师们终于有机会将最终的淫纹施加在你体内。这个淫纹让你无法停止思考下流的事情，你的身体无时无刻处于高度发请状态，你只想让自己绝顶。只可惜你的内棒还被封印着。',
        task: '将你小腹上的淫纹再次升级，增加它的大小和添加更多色情的装饰。从现在开始，当你进行插入任务时必须一边大声呻吟一边做出<a class="link" href="https://hmoegirl.com/阿嘿颜">高潮脸</a>的姿势，想象着自己只通过刺激前列腺就会绝顶。你的最大HP减少3点。',
      },
      {
        name: '魔力榨取容器',
        desc: '由于你身体上被施加的多重淫纹，你以可以让已经被禁止绝顶多时的身体射精为交换条件，自愿成为了魔法师们的魔力供应容器。你被捆绑固定在她们的秘密洋馆的某个位置，身上被标记着“魔力容器”的字样。她们用炼金术和魔法改造了你的身体，让你可以产出比普通人多50倍的精液。仅仅一次射精，就会让你因强烈的快感而彻底屈服。而这样的榨精每天都会进行很多次......',
        task: '准备可以四定在肉棒上的振动锤或者强力跳蛋，以及自缚装备。在身体上写上“魔力容器”和“强制绝顶”等字样。在乳头上固定住两个跳蛋，从及在自己的后穴里插入一个振动棒。然后将振动锤或强力跳蛋紧紧绑在尚未完全勃起的肉棒上，确保所有装备都固定牢靠因为你可能会剧烈挣扎。将自己的双脚、腰部、肩部紧紧地因定在椅子、床或者拘束架上，然后戴上眼罩和一个肉棒型口球，把所有農动设备开到最大后将你的双手也因定住（务必在自缚时确保你能迷脫，并准备安全剪刀!）。你将在所有敏感点都被刺激的情况下被榨精45分钟，设定计时器，接受期间即使射精也不可以逃脱的命运。',
      },
    ]
  },
  'orcish': {
    name: '精神屈服',
    levels: [
      {
        name: '强奸洗脑',
        desc: '一大群绿兽人包围了你，那是你晕厥前眼前景后的景象,然后你又被干醒了，绿兽人一边勤着你这脖子一边狂暴地强奸你。你感到十分痛苦的同时，竟然也感到了一丝快感......',
        task: '佩戴一个项圈，并让它收紧一点（警告: 不要让自己呼吸不畅或血洗不通，若你有任何症状请立刻停止）。然后使用一根大自慰棒以 120 bpm 的速度，以站立或者跪立的姿势从后面不间断地操自己5分钟。你可以通过后面射精。',
      },
      {
        name: '肉棒清理上瘾',
        desc: '你睁开了眼睛，发现几个绿兽人整围着你。他们巨大又肮脏的内棒正对着你的脸，等待着你的口穴去清理它们。渐渐地你心想，似乎没有理由不去侍奉他们',
        task: '使用两根大自慰棒，在龟头冠状沟上加上耻垢 （或者抹上芝士和盐）。一边把一根肉棒的耻垢含在嘴中舔干净，一边用另一根拍打自己的脸和鼻子。清理完一根后，一边给它手交一边用嘴清理另一根。',
      },
      {
        name: '兽人崇拜',
        desc: '你又一次晕了过去，又被绿兽人们轮奸至醒。奇怪的是，你感到自己正在对他们的内棒的大小和气味上瘾，并开始享受这一过程。你心中隐藏的兽人性癖被激活。若你再次失败，你将再也无法摆脱绿兽人的控制。',
        task: '从现在起，你不允许清理你 的身体，包括在任务途中射在你身上的精液。当你与绿兽人类型的敌人战斗时，你造成的伤害减半。',
      },
      {
        name: '兽人专用肉便器',
        desc: '绿兽人们己经完全将你洗脑，你也最终向他们完全屈服。你自愿找到他们，并以专属肉便器的身份加入了绿善人部落。他们将你捆绑起來，并带到了山中深处的部落。你看型了部落中有许多体型各异的绿兽人正盯着你。你被以方便被操的姿势固定在了牢房格子的墙上。每次有兽人想操你的时候，也们只需要打开牢房前栅栏门就可以了，你绝对没有反抗的可能。你的内心很满足，因为你每天都会在快感中升天。',
        task: '戴上口球并以小狗姿势将自己捆绑，或者使用宠物拘束服（双手双脚折叠并固定，你只能用手肘和膝盖走路），训练自己在此姿势下的活动。当你准备好后，将一个大的吸盘自慰棒吸在墙上 （或者任何在这个姿势下更方便被插入的位置，例如门框、柱子上等），然后将自己拘束，爬行10米的距离后，试着将墙上的肉棒插入到自己体内。成功后让自己被操15分钟。在任务中途解开一只手的來缚并且让自己绝顶，但是不管你什么时候绝顶，你都必须被操满15分钟。',
      },
    ]
  },
  'insect': {
    name: '体内产卵',
    levels: [
      {
        name: '胚胎期',
        desc: '等你清醒过来时，感觉肚子里被什么东西填的满满的。你没有太在意，还暗喜那些昆虫并没有对你些什么。直到某天你突然感到肚子一阵翻涌然后你产下了一堆卵。',
        task: '准备一串小号拉珠（直径约 3cm），且将它们润滑后一个个塞入自 己的后穴内。80分钟后将卵排出。排出前，你必须先用手指后庭自慰10分钟，再排出剩的卵。',
      },
      {
        name: '成熟期',
        desc: '你又被昆虫打败然后晕了过去。醒来后你感觉到你被侵犯了，而且发现肚子上有明显的凸起。你又开始产卵，但是这次的卵比上次大得多。这是子官营养化的表现。你的身体已经被改造吗......',
        task: '准备一串中号拉珠（直径约 4cm），将其充分润滑后全部塞入自己体内。80分钟后排出卵，你必须一边排出一边让自己寸止一次。',
      },
      {
        name: '产卵期',
        desc: '你醒来后感到你的身体变得很奇怪。当你发现你产出的卵有一开始的三倍大时，你感到一阵狂喜。你的胸供乎正在变大，每次产卵时的痛觉己经被快感取代。你若再次败北于昆虫族，它们绝对会把你变成它们的苗床。',
        task: '淮备一串大号拉殊（直径约 4.5cm）。在充分扩张你的后穴后，将它们全部塞入。你必须在排出卵前寸止至少3次。且在排卵的时候每排出两个卵寸止至少一次。',
      },
      {
        name: '昆虫苗床',
        desc: '你的身体已经被昆虫充分改造，让你在产卵时能受到巨大的快感。你自愿被昆虫捕获，它们将你带到了巢穴制作成了苗床，作为苗床的你任务只有一个，就是无止境地被强奸然后产下一枚又一枚连续不断的卵，你所产下的卵已经足够虫族组成一只能摧毁人类村庄的军队，但是你并不在意，因为你只需要生活在产卵带来的无尽的快感之中就足够了。',
        task: '在一个温暖的房间中，准备大量温暖的可食用润滑液并且浇在你的全身。准备一个充分煮熟的去壳鸡蛋和一串大号拉珠（直径约 4.5厘米）和一串超大号拉珠（直径约 5cm）。首先充分扩张的你的后穴，然后得大号拉珠充分润滑，全部塞入后，再塞入去壳鸡蛋。你必须一边寸止一边尝试排出鸡蛋，你必须在鸡蛋排出的一最间达到寸止，然后立刻将所有的拉珠在1秒内快速拉出。上述任务需要完成三次，最后用超大号的拉珠再次重复这一过程，你依然必须在鸡蛋被排出的一瞬间达到寸止，但是不同的是，你必须在准备拉出拉珠时开始射精。并且在射精的途中将拉珠全部拉出。任务完成后，你需要吃掉鸡蛋以免浪费食物。',
      },
    ]
  },
};
// 敌人
const enemys = {
  'thieves_brothers': {
    name: '盗贼兄弟',
    race: 'human',
    desc: '一对智通的盗贼兄弟想在森林中找些容易搞定的猎物。要小心，因为他们很容易制服你。',
    hp: 8,
    atk: 'C',
    dick_size: 1,
    dick_prop: [0],
    skills: [
      {
        name: '强盗颜射',
        caption: '他们仅仅是对着你自慰而已...',
        desc: '强盗兄弟开始你面前自慰，他们凑在你身边，让你好好地吸入他们内棒的气味。不一会后，他们射了，直接射在了你的脸上。',
        task: '准备好一小杯约 10mL的精液。将一根自慰棒吸在墙上合适高度位置，然后跪在前面，一边闻肉棒的气味合适高度位一边开始以 60bpm 的遠度自慰。计时结束后让精液浇肉棒口交的在你的脸上。',
        task_duration: 300,
        atk: 1,
      },
      {
        name: '肉棒脸部按摩',
        caption: '他们掏出了自己的肉棒顶在你的脸上...',
        desc: '强盗们强迫你跪在他们面前，然后他们开始在你的脸上摩擦他们的内棒。你只能看着他们用你的脸自慰，他们开始用他们的臭肉棒玷污你的脸。',
        task: '准备好一小杯约 20mL 的精液。将两根自慰棒吸在墙上合适高度位置，然后跪在前面，你必须在一边给一根肉棒口交的同时，一边给另一根手交。计时过半时将 10mL 精液倒在你脸上，计时结束后再倒完剩下的。',
        task_duration: 300,
        atk: 2,
      },
      {
        name: '双人夹击',
        caption: '他们一前一后夹住了你的身体...',
        desc: '强盗兄弟开始猥亵你。他们的手开始刺激你的整个身体，强盗兄弟不遗余力地侵犯着你的身体。',
        task: '抚模你整个身体的性感带。一边骑在一根肉棒上一边给一根肉棒口交。计时过半后，停止口交，但是仍需将肉棒含在口内。你开始专注刺激自己的乳头的同时，寸止至少ー次。结束后饮下 10 mL 精液。',
        task_duration: 300,
        atk: 3,
      },
    ],
    loot: [
      {
        id: 'coin',
        count: 5,
        probability: 6,
      },
      {
        id: 'juice',
        count: 1,
        probability: 3,
      }
    ],
  },
  'werewolf': {
    name: '狼人',
    race: 'beast',
    desc: '一种生活在淫暗森林中的野兽，他们似乎在满月前更加活跃。',
    hp: 8,
    atk: 'B',
    dick_size: 1,
    dick_prop: [3, 4],
    skills: [
      {
        name: '荒野的召唤',
        caption: '野兽在你面前露出了它巨大且怪异的生殖器...',
        desc: '野兽发出了它的交配呼唤，并充分地展现著它勃起的阴茎。通常来说，这种叫声是用来吸引其他雌性野兽的。',
        task: '将一根异形自慰棒吸在墙上合适高度位画，然后跪在前面，用脸从下往上撑住龟头后一边闻肉棒的气味一边开始自慰。你至少寸止一次。想象你面前的肉棒不久就要疯狂地肏你。如果你是兽人种族，你会在完成这个任务后立即进入发情期。',
        task_duration: 300,
        atk: 2,
      },
      {
        name: '野兽颜射',
        caption: '它对你射出了它的野兽精液...',
        desc: '野兽认为你是它潜在的性交对象，并开始在你的身上撒尿。它你身上摩擦它的阴茎，慢慢地用它的尿液和精液的混合物喷向你。',
        task: '准备 100mL 的精液，并混入大约 30mL 的新鲜尿液，然后把精液浇在你的身体上，从脸到胸部到腹部到大腿，你必须在被它覆盖的时候寸止一次。寸止后用你的手把自己擦干净，并舔掉你手上的精液。',
        task_duration: 300,
        atk: 3,
      },
      {
        name: "'射'设领地",
        caption: '它强行将肉棒抵在你的脸上...',
        desc: '野兽闻着你的气味，并在你身上摩撩它的肉棒。你被野兽标记为它们专用的交配对象。它的阴荃带有一种可以让任问人都变得饥渴的强大淫臭。',
        task: '在自慰棒上涂上混有尿液和香水的润滑油，把它在你的脸上和身上到处擦。擦完后将其入你的口穴中,以 80bpm 的速度口交。你必须在口交时寸止一次。若你寸止后还有时间，它将以 100bpm 速度肏你。',
        task_duration: 300,
        atk: 4,
      },
    ],
    loot: [
      {
        id: 'coin',
        count: 7,
        probability: 6,
      },
      {
        id: 'herb',
        count: 1,
        probability: 4,
      }
    ],
  },
  'bee': {
    name: '授精蜜蜂',
    race: 'insect',
    desc: '一只弱小的雄峰，，它的主要任务就是给巨大的花朵或是花妖授粉，以及让冒险者受精',
    hp: 5,
    atk: 'C',
    dick_size: 0,
    dick_prop: [5],
    skills: [
      {
        name: '甜蜜蜜攻击',
        caption: '蜜蜂向你抛射出了它携带的蜂蜜...',
        desc: '蜜蜂常常携带少量的蜂蜜作为防御掠夺者的武器，一般情况下，这种蜂蜜可以让任何东西都动弹不得。这种蜂蜜来自于一种催情植物的花粉，所以有很不错的催情效果...',
        task: '准备大约20毫升的蜂蜜。倒一些在你的脸上和胸上，并且用蜂蜜作为润滑液让自己寸止至少一次。催情蜂蜜让你变得兴奋且逐浙失去注意力。你下一次攻击造成的伤害减2',
        task_duration: 300,
        atk: 1,
      },
      {
        name: '身体探针',
        caption: '蜜蜂正在分析你的身体...',
        desc: '蜜蜂将你抓住并且在你面前展示了它即将插入你体内的“毒刺”。它用触角抚摸着你的身体，用“毒刺”在你身上涂抹粘液，奇怪的是，你忽然感到很热。',
        task: '拿出自慰棒，用它“探测”你身体的敏感部位，刺激你的乳头等位置。然后把毒刺深深地播入你的菊穴3秒，拔出后继续这个过程。',
        task_duration: 300,
        atk: 2,
      },
      {
        name: '授精攻势',
        caption: '蜜蜂把你紧紧抱住并射入了它的卵...',
        desc: '这只蜜蜂试图将它的卵射入你体内。它成功了，但你需要立即把卵排出來，防止卵子在你体内成熟。',
        task: '用绳子或束缚胶带把你的胸部绑紧（不要让自己呼吸困难）。准备一串中等大小拉珠(直径约 3.5cm)，把它和500mL的水/润滑液混合的灌肠液一起塞进你的后面。然后在剩下的5分钟内必须寸止至少一次，在寸止的瞬间将灌肠液和拉珠排出。',
        task_duration: 300,
        atk: 3,
      },
    ],
    loot: [
      {
        id: 'coin',
        count: 3,
        probability: 6,
      },
      {
        id: 'honey',
        count: 1,
        probability: 3,
      }
    ],
  },
  'normal_orcish': {
    name: '部落兽人',
    race: 'orcish',
    desc: '一个兽人正在寻找新的玩具（冒险家）带回他门的村庄，他异常强壮。',
    hp: 10,
    atk: 'A',
    dick_size: 2,
    dick_prop: [1, 6],
    skills: [
      {
        name: '强制魔力回复',
        caption: '兽人强迫着你喝下一种白色液体...',
        desc: '他强行打开你的嘴，并取出一小瓶他的精液。大多数绿兽人都会携带他们的精液，他们的目标是强迫对方屈服于他们的性能力之下...',
        task: '跪下来，把大量精液在一个杯子里。捏住你的脸，强行打开你的嘴。想象着兽人强迫你张嘴，这样你就可以喝下他们的“魔力”了。让精液满到溢出来（不要咽下去哦）。',
        task_duration: 300,
        atk: 2,
      },
      {
        name: '兽人肉棒猛击',
        caption: '绿兽人在你的脸上拍打他的肉棒...',
        desc: '绿兽人掏出内棒，猛烈地柏在你的脸上。他们的肉棒大力摩擦你的脸，好像你对他来说仅仅是一个物品。你最终屈服了，自愿为他口交......',
        task: '拿出仿真自慰棒，在冠状沟处加上耻垢（芝士和盐）。用肉棒反复拍打你的脸，让脸有点疼。然后以 80bpm 的速度口交。你必须计时结束前至少深喉肉棒一次。',
        task_duration: 300,
        atk: 3,
      },
      {
        name: '兽人强奸',
        caption: '绿兽人粗暴地玩弄着你...',
        desc: '绿兽人从后面抱住你，一边大力揉捏你的身体，一边在你身后蹭他们的肉棒。',
        task: '把肉棒吸在你身后的墙上，让它以 60bpm 的速度操你。每次抽插都需要拔出到龟头处并且插入最深处。同时挤压你的乳头和乳房，大声呻吟，偶尔打自己的身体。你需要在他操你时寸止至少一次。',
        task_duration: 300,
        atk: 5,
      },
    ],
    loot: [
      {
        id: 'coin',
        count: 8,
        probability: 6,
      },
      {
        id: 'jerky',
        count: 1,
        probability: 3,
      }
    ],
  },
  'sorceress': {
    name: '诱拐法师',
    race: 'enchanter',
    desc: '一个女法师。她给人的第一印象十分善良，但这是一个误会，因为她会不惜一切代价捕获冒险者。',
    hp: 8,
    atk: 'B',
    dick_size: 0,
    dick_prop: [7],
    skills: [
      {
        name: '符咒: 除你武器',
        caption: '法师用魔咒强行把你剥光了...',
        desc: '法师施放的风系法术可以用来解除敌人的武器，但同样也可以让敌人一丝不挂。在施法之后，她强迫你为她们表演一个节目。',
        task: '除了BDSM装备或贞操带之外，你身上穿的每件衣服都要被脱光。此效果在本场战斗中持续生效。用跳蛋刺激你的肉棒。想象一大堆法师女孩正在一边嘲笑一边看你自慰。',
        task_duration: 300,
        atk: 1,
      },
      {
        name: '符咒: 强制射精',
        caption: '法师用魔咒强迫你射精...',
        desc: '法师施展了一个强大的精神攻击，可以使任何意志薄弱的人产生无比幸福的射精。射精只是感觉上的精神效果，你不会因此而绝顶。虽然使用卷轴或者是魔力更强大的法师可以做到。',
        task: '让自己的肉棒寸止到极限，然后稍稍越过极限后，立刻停止所有刺激，完成一次毁灭高潮。你在射精途中不可以做任何刺激。如果你有贞操带，那么你可以暂时解开它，让自己的身体寸止一次，但你不可以射精。',
        task_duration: 300,
        atk: 2,
      },
      {
        name: '符咒: 羞辱幻境',
        caption: '法师让你如临梦境般的幻境...',
        desc: '法师施展了一个幻术。你正以为自己正赤身裸体地走在一个小镇上。法师召唤出肉棒，将精液喷到你身上，让镇上的人嘲笑你。你什么也做不了，只能感到无尽的羞辱，被幻觉弄得又脏又湿。',
        task: '脱光衣服，用精液涂满全身，走到屋外或建筑内的其他地方。现在呆在外面躲5分钟。如果你在任务途中寸止，则你受到的伤害减半。',
        task_duration: 300,
        atk: 6,
      },
    ],
    loot: [
      {
        id: 'coin',
        count: 6,
        probability: 6,
      },
      {
        id: 'scroll_climax',
        count: 1,
        probability: 3,
      }
    ],
  },
  'aphrodisiac_plant': {
    name: '催情植物',
    race: 'tentacle',
    desc: '森林和沼泽中常见的寄生植物。它试图将任何它能捕获的生物它融为一体。',
    hp: 10,
    atk: 'C',
    dick_size: 1,
    dick_prop: [8, 5],
    skills: [
      {
        name: '信息素迷雾',
        caption: '它向你喷射了大量信息素...',
        desc: '触须植物会伸出它的触须，争先恐后地扑向你的脸。它向你射出一些白色的精液。这种信息素具有强大的催情作用。',
        task: '准备 50mL 精液和一些大香肠或软而长的肉棒。跪下给所有肉棒口交，想象它们射在你的脸上。一边吮吸肉棒，一边慢慢地把精液滴在脸上和身上。你必须做出非常饥湿的样子。',
        task_duration: 300,
        atk: 1,
      },
      {
        name: '溶解酸液',
        caption: '它试着把你捆绑起来...',
        desc: '这种植物用它的藤蔓覆盖你的身体。分泌出的粘液开始溶解你的衣服，还把它的一些催情信息素喷到你裸露的皮肤上。催情液对你会很有效。',
        task: '准备 50mL 精液，脱到只剩BDSM装备。裸体使用2根肉棒将精液涂抹在身体上。一定要把它擦遍全身。5分钟內必须把精液全涂上去。',
        task_duration: 300,
        atk: 2,
      },
      {
        name: '触手缠绕',
        caption: '它成功抓住了你...',
        desc: '触手开始缠绕你的身体为寄生做准备。你试图抵抗它的俘获。很幸运，如果你还有HP的话，就可以轻松逃离。',
        task: '拿些绳子把自己绑起来。把绳子覆盖在你的胸部，大腿和腿上。系紧后你必须使自己寸止。当你寸止时，你必须试图通过扭动你的身体来解开自己。如果你在做这个任务时射精，你受到的伤害增加3点。',
        task_duration: 300,
        atk: 3,
      },
    ],
    loot: [
      {
        id: 'coin',
        count: 3,
        probability: 6,
      },
      {
        id: 'philter',
        count: 1,
        probability: 3,
      }
    ],
  },
};
// 阴茎尺寸
const dick_sizes = [
  {
    name: '小号阴茎',
    desc: '9-12cm长 3cm粗',
  },
  {
    name: '中号阴茎',
    desc: '13-15cm长 4cm粗',
  },
  {
    name: '大号阴茎',
    desc: '16-18cm长 5cm粗',
  },
  {
    name: '特大号阴茎',
    desc: '19-22cm长 6cm粗',
  },
]
// 阴茎属性
const dick_props = [
  {
    name: '多汗',
    desc: '在任务开始前将自慰棒一遍盐水',
  },
  {
    name: '耻垢',
    desc: '在自慰棒的尖端加上芝士和盐',
  },
  {
    name: '多毛',
    desc: '将毛发(阴毛或任意毛发) 固定在自慰棒的根部',
  },
  {
    name: '麝香',
    desc: '你必须在任务前将阴茎浸泡一遍尿液和少量香水的混合物',
  },
  {
    name: '怪异',
    desc: '使用弯曲/带刺/动物形状的自慰棒',
  },
  {
    name: '黏糊糊',
    desc: '你必须在插入时使用双倍的润滑液。',
  },
  {
    name: '仿真',
    desc: '你必须使用仿真自慰棒',
  },
  {
    name: '魔法',
    desc: '她们用魔法来让魔杖像性爱玩具一样震动。你必须使用震动棒或跳蛋代替自慰棒。',
  },
  {
    name: '触手',
    desc: '使用长而软的肛条或自慰棒。',
  }
]
// 种族
const race_info = {
  'princess': {
    camp: 1,
    name: '人类: 王室公主',
    hp: 14, 
    atk: 2,
    desc: '你转生成为了人类王室的一员。可别高兴得太早，在这个世界中，贵族身份更像是一种诅咒。所有公主最后都有一个悲惨的命运!被绑架、被强奸、又或是堕落，这就是这个世界里太多数公主的结局。你能在这个世界身为公主存活下来吗？',
    clothes: {
      name: '皇家服饰',
      desc: '公主平时通常都穿着公主的衣服。由于在新规则之下性行为变得极为常见，所以所有的女性王室成员都被强制要求佩戴操带以防止被不纯血统污染。',
      task: '你需雯戴上金色头发、长连衣裙、长手套和贞操带。你所有涉及到肉棒的任务都变为后穴任务。寸止任务变为以150 bpm欺负你的后穴。',
    },
    passive_skill: [
      {
        name: '父王的钱包',
        desc: '由于王室持有大量的土地和征收着大量的税收，室成员们都极端富有。你在出发之前从皇家金库里拿走了一笔可观的启动资金。',
        task: '在你开始冒险时，在你的背包里加入<span class="color_coin">50金币</span>和一把<span class="color_key">[宝箱钥匙]</span>。但是每当你受到<span class="color_curse">诅咒</span>时，都要失去<span class="color_coin">50金币</span>。',
      },
      {
        name: '喜欢被捕',
        desc: '公主天生就是用来被抓的。由于她们在王室中被要求一生都保持贞洁，所以每次她们披抓后，都会不停地在脑子里想象接下来可能发生的事情而变得异常高兴。',
        task: '每次你受到<span class="color_curse">诅咒</span>时，增加并回复 1 点最大生命值（最多6次）。每受到三个<span class="color_curse">诅咒</span>，增加1点攻击力（最多3次）。',
      },
    ],
    active_skill: [
      {
        name: '不雅照片',
        task: '让敌人好欣赏你下流的身体! 张开你的双腿，露出你的内衣，双手刺激你的乳头，想象你的敌人正在津津有味地看著你。',
      },
      {
        name: '贵族服务',
        task: '用你自慰棒或者前列腺刺激道具按摩你的后庭，重点刺激你的前列腺。如果有前列腺液溢出，那么你下次攻击造成的伤害增加1点。',
      },
      {
        name: '皇家表演',
        task: '你可以暂时移除你的贞操带并寸止至少一次。如果你在此任务中射精，则会立即输掉此次战斗。在你寸止的时候，你必须做出<a class="link" href="https://hmoegirl.cyou/啊嘿颜">啊嘿颜</a>以表示你正在做与王室成员的身份极不相符的事情。',
      },
    ],
    ult: {
      name: '指挥特权',
      desc: '公主可以利用她的魅力和特权指辉任何种族以她的命令行事。王室管辖下的所有生物都会受到此技能的影响。',
      task: '当此技能被发动时，你必须用自慰棒或者前列腺刺激道具刺激你的前列腺，直到有前列腺液流出。你的敌人会被眩晕1回合（跳过敌人的该回合），且你自己回复5点生命值。',
    },
  },
  'wizard': {
    camp: 1,
    name: '人类: 白浊法师',
    hp: 15,
    atk: 2,
    desc: '你转生成为了这个世界上最著名的人类魔法师之一。作为一名法师，你主要使用精液作为魔力的来源，还会使用古老的符文力量来强化自己的身体。由于恶魔领主的影响，所有的符文文字都变成了“荡妇”或者是“小穴”之类的文字。太下流了!',
    clothes: {
      name: '魔女长袍',
      desc: '魔女平时通常都穿着魔女的衣服。由于淫乱的新规则，这个世界的法师通常穿得比较少。她们通常使用腰带将魔力瓶挂在自己的腰上。',
      task: '购买并穿着“性感魔女服装”。佩戴一条用于悬挂魔力瓶的腰带。',
    },
    passive_skill: [
      {
        name: '魔力收集者',
        desc: '魔力是通过攝入精液产生的，你需要消耗魔力来释放符咒。你随身都携带着由保险套做成的魔力瓶，里面装有可随时使用的精液。',
        task: '在开始游戏时获得15个<span class="color_common">[魔力瓶]</span>。每当你发动攻击时，都需要摄入一个魔力瓶内的精液。每当你或者敌人在事件中射精时，你可以重新装填1个<span class="color_common">[魔力瓶]</span>。你每有10个<span class="color_common">[魔力瓶]</span>，获得3点最大生命值。',
      },
      {
        name: '魔力填装',
        desc: '法师可以随时间自我生成魔力。但是由于肉棒增大术需要消耗非常多的魔力，法师们总是不满足于自己的魔力存货。',
        task: '当你移动到下ー个格子时，获得2个<span class="color_common">[魔力瓶]</span>。',
      },
    ],
    active_skill: [
      {
        name: '符文: 淫荡低语',
        task: '在你的身体的显眼部位写下符文文字“下贱母狗”或者是其他下流文字来攻击你的敌人。在书写完成后你必须寸止至少一次。',
      },
      {
        name: '魔力摄取表演',
        task: '将两个魔力瓶中的精液倒入你的口中。向你的观众展示你口中的精液，并且在展示的过程中寸止至少一次。',
      },
      {
        name: '魔力大量颜射',
        task: '将三个魔力瓶中的精液浇在自己的脸上。然后以 70bpm 的速度使用中号自慰棒操自己的口穴。让肉棒沾满精液并且继续给肉棒口交。最后用口穴把肉棒消理干浄。',
      },
    ],
    ult: {
      name: '快速魔力填充',
      desc: '在危急时刻的备用技能。法师使用最后的法力来迫使她们自己的身体产生精液。由于会对身体造成不小的压力，所以这个技能一天只能使用一次。',
      task: '当这个技能发动后，你必须寸止一次然后射精，精液必须直接射入你的口中。将精液吞下后，你获得5个<span class="color_common">[魔力瓶]</span>。使用此技能将跳过你的下一个攻击回合。这个技能一天只能使用一次。',
    },
  },
  'elf': {
    camp: 1,
    name: '精灵: 暗夜窃贼',
    hp: 10,
    atk: 2, 
    desc: '你发现自己被转生成了一位暗夜精灵。暗夜精灵是所有精灵中身手最敏捷的，也是受恶魔领主影响最大的种族。因为她们有着这个世界上最诱人的酮体以及对快感最低的耐受能力。这使便得几乎所有的种族对暗夜精灵都有着好感。',
    clothes: {
      name: '下流盗贼',
      desc: '现在所有的精灵都接受了她们新被赋矛的下流的属性，你也不例卧。这就是现在精灵盗贼通常的穿着。由于恶魔领主的新规则，追求服装的隐蔽性已经过时了。',
      task: '你需要穿着一件露腹短上衣和一件迷你裙或是迷你短裤。你还可以穿一件斗篷。',
    },
    passive_skill: [
      {
        name: '快感不耐受',
        desc: '恶魔领主的新规则让暗夜精灵受到了极大的英雄。你们的敏感度是其他种族的三倍，所以通常会更快地成为敌人的牺牲品。',
        task: '当进行插入任务或者在战斗中被肉棒插入时，你必须发出舒服的呻吟以及做出绝顶的表情。',
      },
      {
        name: '气味上瘾',
        desc: '肉棒的气味是暗夜精灵的弱点之一，只要她们闻到肉棒的气味就会开始发情。你无法柜绝他人给你的口交命令。',
        task: '你所有的口交任务的时长加5分钟。并且每次口交任务结束后口中都会被射入 20ml 的精液。',
      },
    ],
    active_skill: [
      {
        name: '精灵的技巧',
        task: '舔一根小号自慰棒并口交2分钟。然后在剩下的时间以 40bpm 缓慢抽插你的后庭。',
      },
      {
        name: '偷窃: 肉棒',
        task: '你使用黑魔法将你敌人的肉棒转移到了你的附近，根据敌人肉棒的特征，例如<span class="color_dick">[黏滑]</span>、<span class="color_dick">[耻垢]</span>来准备你的自慰棒。以 70bpm  和骑乘位便用肉棒5分钟。中途必须寸止至少ー次。',
      },
      {
        name: '盗贼之舞',
        task: '你向你的敌人展示了你作为盗贼的高超的隐蔽技巧，在你的房间外一个隐蔽的地方寸止至少一次来完成任务。如果隐蔽在室外，则此回合攻击加1。',
      },
    ],
    ult: {
      name: '狩精步伐',
      desc: '精灵盗贼的特殊技能，可以立刻消除你的存在气息来迷惑你的敌人。但是你不能用这个校技能来脫离战斗。',
      task: '一个攻击回合将被跳过，并且在你下一次攻击时使你的攻击力翻倍。',
    },
  },
  'dwarf': {
    camp: 1,
    name: '矮人: 淬茎师',
    hp: 15,
    atk: 2,
    desc: '你转生成为了一名矮人铁匠，她们是这个世界身体最结实的种族，能够忍受更大的肉棒。矮人还因为她们的特有的料技，以及那些经常在战斗中被使用的性爱玩具而闻名于界。不过，因为她们的身体只有人类小孩的大小，所以敌人通常能在力量上碾压她们。',
    clothes: {
      name: '尺寸过大',
      desc: '矮人的衣服通常是从人类小孩那买的二手货。即便如此，这些衣股穿在矮人身上也经常松松垮垮的。',
      task: '你需要穿一件明显尺寸过大的松垮衣服，如3XL或者4XL。作为矮人，你不可以穿着内衣内裤。你可以穿着任意种类的衣服，只要它们的尺寸是过大的。',
    },
    passive_skill: [
      {
        name: '手交精通',
        desc: '矮人的双手通常是极度柔嫩且技巧高超的。就像使用手工工具一样，她们能以极度精准的手法管理握在自己手中的阴茎。',
        task: '你所有的手交任务的持续时闻减半。每当你进行手交任务后，投一次骰子，若投出的点数大于等于4点，则对你的敌人造成3点伤客。',
      },
      {
        name: '体型劣势',
        desc: '矮人最伯与敌人发生战斗，因为体型差距实在太大了。她们最害怕的就是野兽族或者其他大型种族的敌人。与这样的敌人战斗会让她们很快失去战斗的意愿。',
        task: '如果你正在同一个有着小号阴茎的敌人战斗，将敌人的阴茎尺寸增加一个等级。当你与拥有大号明茎的敌人战斗时，你的攻击力减1。',
      },
    ],
    active_skill: [
      {
        name: '吃掉! 矮人口交',
        task: '你需要给一根大号自慰棒以 40bpm 的速度口交，并且一边口交一边用你的手刺激自慰棒。',
      },
      {
        name: '压倒! 矮人插入',
        task: '你把肉棒的头部插入你的后庭来攻击你的敌人。缓慢地以 60bpm 的速度抽插自慰棒的尖端，并且寸止至少一次。',
      },
      {
        name: '科学! 矮人充能装置',
        task: '你在性爱战斗中使用矮人道具。将一颗大号跳蛋或者震动自慰棒插入后庭并启动。并且你的肉棒插入自慰套中。在自慰套里寸止至少一次。',
      },
    ],
    ult: {
      name: '给我变大吧!',
      desc: '铁匠能将敌人的阴茎进行“淬火”，这能増加它的大小以及敏感度，从而对双方都造成更大的伤害。',
      task: '当你发动此技能后，敌人肉棒的尺寸在下ー回合将增大一个等级。当敌人对你进行的攻击结束之后，敌人立刻受到5点伤害。',
    },
  },
  'beastwoman': {
    camp: 1,
    name: '兽人: 淫狐武士',
    hp: 15,
    atk: 2,
    desc: '你转生变成了兽人部落中的一个骄傲的武士。大多数兽人都长着各种各样的动物耳朵，还有着一个固定的发情期。兽人武士是所有武士中最出色的一支，因为当她们发情时，她们可以化这种求而不得为力量。以性欲为武器无疑是强大的，但是这也会让她们变得疯狂。',
    clothes: {
      name: '兽族样貌',
      desc: '兽人通常都佩戴着项圈轻装上阵。为了能让尾巴有地方放，她们的衣服是特制的。',
      task: '你需要穿着紧身衣和项圈。当你的后庭没有被使用时，必须时常佩戴肛塞尾巴。当你进入发情期时，你四肢以外的部分不能穿着任何衣物。',
    },
    passive_skill: [
      {
        name: '定时交尾',
        desc: '兽人们有发情周期。你每走过3个格子，你将进入发情期。若你没有在3个格子内发动你的特殊技能，发情期将自动结束。',
        task: '当你进入发情期时，你的最大生命值将暂时减少5，你的攻击力将暂时增加1。在任何需要使用润滑剂的任务中 ，你必须使用双倍的润滑剂，并且所有的bpm将+30。在进行任务时你必须大口喘气并且在舒股的时候发出声音。',
      },
      {
        name: '兽族血脉抑制',
        desc: '当兽人发情时，她们通常会被戴上口球，用来防止她们不受控制地给任何像是肉棒的物体口交的欲望。',
        task: '当你进入发槽期时，只要在任务没有使用你的口穴的时候，都必须戴上口球。你将无法购买东西，也无法得到牧师的服务，因为你不能说话。',
      },
    ],
    active_skill: [
      {
        name: '兽人诱惑',
        task: '你四脚着地并且将你的后庭展示给敌人。用手指以 50 bpm 的速度后庭自慰并且寸止至少一次。',
      },
      {
        name: '兽性大发',
        task: '你必须躺下并且张开你的双脚，摆成M型朝向你的敌人。用手指以 100bpm 的速度后庭自慰，并且寸止至少ー次。',
      },
      {
        name: '自慰狂乱',
        task: '使用自慰棒以 100bpm 进行后庭自慰，并且用另一只手寸止。每当你寸止时，你必须做出绝顶表情，并且更换你的自慰棒。你必须寸止至少两次。想象你正在把这一切展示给你的敌人。',
      },
    ],
    ult: {
      name: '淫欲散发',
      desc: '兽人可以利用她们发情时的热量来提高技能的效果。兽人武士可以通过压制她们的理智释放自己的欲望，这将增强她们的性能力，但是使用过后会进入贤者时间。',
      task: '你只有在发情期时可以发动此技能。技能发动后，以最快速度寸止一次。你的生命值将减少5点，在接下的两次攻击中，你的攻击カ将提高3点。只有当你的生命值大于5点时才可以发动此技能。',
    },
  },
  'holstaurus': {
    camp: 1,
    name: '牛头人: 圣乳骑士',
    hp: 15,
    atk: 2,
    desc: '你转生成为了一名<a class="link" href="https://zhmonstergirlencyclopedia.miraheze.org/wiki/荷斯陶洛斯">荷斯陶洛斯</a>，她们是弥诺陶洛斯的后代，一种人类和牛的混血产物。因为她们的精液和乳汁具有治疗效果所以被世界所熟知。由于她们身体强壮，能够承受更多惩罚，所以偏向防御的职业，例如圣骑士是与她们相性最好的职业之一。',
    clothes: {
      name: '奶牛装甲',
      desc: '荷斯陶洛斯对她们身为牛族的身份感到非常自豪，不管去哪都穿着奶牛图案的衣服。脖子上的牛铃会让她们回想起自己的牧场的家。',
      task: '你需要穿着D罩杯胸罩并使用水气球或其他重物填充。你的衣物上印有奶牛图案，并且需要佩戴一条挂有牛铃铛的项圈。',
    },
    passive_skill: [
      {
        name: '荷斯陶洛斯乳业',
        desc: '每当你走过5个格子之后，荷斯陶洛斯将产生牛奶，并且给予你一个<span class="color_uncommon">[荷斯陶洛斯牛奶]</span>。但是你必须刺激你的胸部来完成这个过程。',
        task: '当你准备准备榨乳时，一边揉搓挤压你的胸部和乳头，一边用一根自慰棒或者前列腺按摩器刺激你的前列腺。你需要持续5分钟来完成这个任务。',
      },
      {
        name: '不堪重负',
        desc: '荷斯陶洛斯的胸部又大又重。这让她们的速度变得迟钝。同时也让她们获得了最想要的奴隶种族榜单上的前三名的位置。',
        task: '每当你攻击时，投一次骰子进行速度判定。若点数为1-2，则你的攻击力下降1点。',
      },
    ],
    active_skill: [
      {
        name: '乳头集中',
        task: '你必须在接下來的5分钟内集中玩弄自己的乳头。不可以触碰身体其他的地方。',
      },
      {
        name: '牛奶催产',
        task: '你需要骑在一根肉棒上的同时，揉搓你的胸部，拨弄你的乳头。想象你正在给你的敌人表演如何刺激胸部。',
      },
      {
        name: '寂寞母牛',
        task: '你必须使用乳头吸引器或者跳蛋等乳头玩具来给自己榨乳，同时大声呻吟，直到你的乳头被充分玩弄。你必须一边刺激乳头一边至少寸止一次。',
      },
    ],
    ult: {
      name: '肉体护盾️',
      desc: '圣骑士能够凭借其强大的忍耐力抗下任何攻击。荷斯陶洛斯可以暂时増强她们的肉体，把自己变成一面真正的肉盾。',
      task: '当技能发动时，你从敌人的下两个攻击回合中受到的伤害将减半。但是所有的bpm将+20，且阴茎尺寸得増加一个等级。',
    },
  },
  'witch': {
    camp: 2,
    name: '人类: 触装魔女',
    hp: 15,
    atk: 2,
    desc: '你转生成为了一位人类女巫!不像追随光明的法师，女巫信奉深邃的黑暗力量来强化她们的法力。你获得了高于常人的魔力，但是也付出了代价。在你释放你的符咒时，缠绕在你身上的触手会因为感知到了魔力的突然増加而玩弄你身体的每个角落。',
    clothes: {
      name: '触手服',
      desc: '女巫通常会穿着弹力且贴身的衣服来防止触手侵犯她们。但是有的时候触手依然会从缝隙钻入并且寄生在服的内侧，并给她们带来持续的侵犯。',
      task: '在你执行任务时，你需要穿着一件紧身泳衣（死库水），或者其他能够尽可能地贴紧身体的衣物。',
    },
    passive_skill: [
      {
        name: '触手控制',
        desc: '女巫可以召唤并控制蝕手。不过它们通常会无差别地侵犯所有生物，即使召唤它们的女巫也逃不掉。',
        task: '准备大量煮熟冷却后的有韧劲的面条，并加入润滑剂搅拌均匀，每次你攻击时都需要在你的衣服中加入一把面条作为缠绕在你身上的触手。',
      },
      {
        name: '召唤失控',
        desc: '当女巫的召唤术失控时，大量的触手会摆脱女巫的控制并将你淹没。你会为你的失误得到应有的惩罚。',
        task: '当你第三次战斗败北时，你需要将所有的面条浇入你的衣服。在后庭中注入 500mL 牛奶并插入震动自慰棒。给另一根自慰棒深喉总计1分钟，并且在结束后吞下 100mL 精液。',
      },
    ],
    active_skill: [
      {
        name: '魔力吸入',
        task: '去弄一些精液和棒状蔬菜（黄瓜等）。将精液含在口中，一边自慰一边给棒状蔬菜口交，吞下口中精液的同时寸止。',
      },
      {
        name: '召唤术: 寄生生物',
        task: '去弄一些大香肠等棒状食物，将其插入你的肛门。把一些煮熟的面条塞进你的衣服里，然后寸止至少一次。',
      },
      {
        name: '召唤术: 随从',
        task: '你召唤了数根粗杜的触手，它们开始玩弄你的身体。将两颗跳蛋贴在自己的乳头上，再塞入一颗到后庭中，想象被触手攻击并寸止至少一次。',
      },
    ],
    ult: {
      name: '触手天国',
      desc: '你召唤了一大堆不同种类的触手，它们会束缚和侵犯靠近它们的任何生物。',
      task: '当技能发动时，将自己的身体涂满润滑液，并且在衣服中塞入煮过的面条。将你的双脚捆绑在一起，并且用自慰棒同时侵犯的口穴和后庭（所有的洞）10分钟。你的敌人受到5点伤害。',
    },
  },
  'succubus': {
    camp: 2,
    name: '莉莉姆: 饮精魅魔',
    hp: 15,
    atk: 2,
    desc: '你转生成为了一个魅魔。魅魔的唯一食物就是纯净的魔力，也就是精液。这使得她们必须要尽可能多得狩猎男性敌人以获得充足的食物来源。可惜的是，你似乎只是一只莉莉姆，一种在魅魔的等级划分中处于最底层的魔物。让自己充分地做好准备吧!',
    clothes: {
      name: '迷你比基尼',
      desc: '大多数魅魔都是不穿衣服的。但是她们也学会了使用内衣让自己看上去更加性感。',
      task: '你需要穿着一件迷你或者微型比基尼。在你的小腹上用记号笔画上一个心型淫纹。每当你射精或寸止后，升级淫纹的大小和复杂度。',
    },
    passive_skill: [
      {
        name: '精液榨取',
        desc: '魅魔有着让雄性强制产生更多精液的能力。这个能力是很关键的，因为如果他们只能产生和平时一样多的量的话，很容易在魅魔的榨精下死亡。',
        task: '在除了你攻击任务以外的其他涉及精液的任务中，你必须使用双倍的精液量。',
      },
      {
        name: '精液渴望',
        desc: '当魅魔感到饥饿时她们会进入发情状态且不受控制地攻击她们见到的下一个雄性。如果你不想让自己失控的话，最好随时用精液填满你下面的嘴。',
        task: '如果你连续走完了两个格子的事件，而没有饮下或被注入任何精液的话，暂时降低5点你的最大生命值，且所有任务的bpm增加20，直到你饮下或被注入精液为止。',
      },
    ],
    active_skill: [
      {
        name: '精液抽取',
        task: '你无视敌人的意愿柚取他们的精液。准备 20mL 的精液，在喝下去时寸止一次。',
      },
      {
        name: '精液魔术',
        task: '在一个碗里倒入 100mL 精液，然后将其全部浇在自己脸上，并把流下去的精液涂抹身体上。当你全身沾满精液时，寸止至少ー次。像一个魅魔一样。',
      },
      {
        name: '符咒: 媚惑',
        task: '你必须摆出一个可爱姿势并且保持这个姿势自慰。当你达到寸止时，你必须摆出剪刀手高潮脸的姿势并且射精来完成你的攻击。如果你在镜子前射精，则下次攻击的攻击力増加1点。',
      },
    ],
    ult: {
      name: '能量灌注',
      desc: '魅魔可以将敌人的精力恢复到最佳状态，以从他们身上榨取更多的精液。',
      task: '当技能发动时，敌人的生命值回复5点。将 200mL 精液浇在你的脸和身体上。你的下三次攻击的基础攻击力增加2点。',
    },
  },
  'asceticist': {
    camp: 2,
    name: '人类: 禁欲教徒',
    hp: 20,
    atk: 2,
    desc: '你转生变成了一个普通的人类......哦等等，你身上似乎携带着束缚神教的标志。她们把自己捆绑起來，获得痛苦，以祈求束缚神的恩赐。她们越是让自己到痛苦、越是让自己受尽羞辱，束缚神给予她们的力量就越是强大。',
    clothes: {
      name: '捆绑套装',
      desc: '你需要在你的常规衣服内穿戴紧缚绳或者束缚道具以持续折磨你的内体。',
      task: '你可以穿着普通衣物，但是在衣物之下你的上身和裆部必须穿戴紧缚绳以持续摩擦你的身体。当你执行不需要口穴的任务时，必须佩戴口球。你必须经常解开紧缚以防窒息和血栓。',
    },
    passive_skill: [
      {
        name: '受虐狂',
        desc: '所有的教徒们都有将痛苦转化成快感和魔力的能力。她们不需要使用精液来释放符咒，不过要让自己始终处于痛苦之中。',
        task: '发动攻击前，你需要置自身于痛苦之中。发动攻击前，你需要用道具抽打自己的屁股、大腿内侧或乳头等敏感部位。<span class="color_bad">[弱击]</span> 10下，<span class="color_useful">[有效]</span> 20下，<span class="color_key">[会心]</span> 30下。不可以手下留情哦～',
      },
      {
        name: '贞操誓言',
        desc: '因为射精禁止带来的痛苦，佩戴贞操带也能増加教徒们的力量。教徒们需要永久佩戴贞操带来便她们时刻保持发情状态。',
        task: '你需要时刻佩戴贞操带。你所有涉及到肉棒的任务都变为后庭任务。寸止任务变为以 150bpm 欺负你的后庭。',
      },
    ],
    active_skill: [
      {
        name: '缚法: 禁欲',
        task: '由于你佩戴了贞操带，所以无法射精。在你后庭中塞入个跳蛋，然后玩弄自己的乳头。',
      },
      {
        name: '缚法: 羞辱',
        task: '你必须在敌人面前差辱你自己。将你的束缚解开并且在你身体上的三个部位写下三个淫秽的记号。然后将双手背在头后，在舞蹈中向敌人展示你的身体。',
      },
      {
        name: '缚法: 苦痛',
        task: '将你的束缚解开并且使用拍板或者其他能抽打你的道具。每隔10秒抽打自己的屁股、大腿内侧或乳头等敏感部位，然后说出束缚神教的祷告词——“我是一个喜欢被打的贱狗”。在完成前的最后一次抽打将抽打在你的生殖器（贞操锁）上。',
      },
    ],
    ult: {
      name: '缚法: 痛苦转移',
      desc: '当自己遭受巨大痛苦时，教徒们能将自己所受的痛苦以同等剂量施加在她们的敌人身上。这是在绝望时刻相当实用的技能。',
      task: '发动技能后，你需要在两个乳头戴上乳夹 然后使用道具狼狼抽打你的屁股和生殖器各十次，然后对你的敌人造成你已失去的生命值的伤害。使用此技能将跳过你的下一个攻击回合。',
    },
  },
  'zombie': {
    camp: 2,
    name: '不死族: 冷血僵尸',
    hp: 20,
    atk: 2,
    desc: '你转生成为了一个自由的不死者。通常不死者都服待于召唤他们的死灵法师，但偶尔也有自然生成的依靠自己的意志行动的她们。不过，她们仍然行动迟缓且大多数时候只遵循自己的本能，寻找内棒以给她们带来温暖和生命。',
    clothes: {
      name: '破烂衣装',
      desc: '大多数不死者并没有时髦的衣服。她们还穿着她们生前穿着的服饰，尽管很多已经腐烂或者破碎。',
      task: '穿着带有破洞的衣服和丝袜。你可以随自己喜好载剪，但是要让乳头和私处暴露出来。给自己化个不死者特有的黑眼圈。',
    },
    passive_skill: [
      {
        name: '行尸走肉',
        desc: '由干不死者只是她们生前的一型内体躯壳，所以她们并不能感觉到痛觉或是人类其他的情感。这使得她们成为了最好的用来当做自慰套的物品之一。不幸的是，她们的气味很糟糕。',
        task: '从现在开始，作为一个不死者，你不能在任务中途洗澡或是清理自己的身体。当你进行任何任务的时，尽你最大可能不要露出任何表精或是发出任何声音。此技能的优先级在其他强制淫语的要求之上。',
      },
      {
        name: '强韧',
        desc: '因为不死者已经......死了，所以她们并不担心任何对她们身体造成的物理伤害。当不死者处予魔力浓度高的环境中时，她们吸取空气中的魔力来缓慢修复自己的身体。',
        task: '在你的攻击回合开始时，你回复1点生命值。',
      },
    ],
    active_skill: [
      {
        name: '霜冻之触',
        task: '将你的双手泡在冰水中15秒。然后用手指做后庭自慰，并且用另一只手寸止至少一次。',
      },
      {
        name: '无意识自慰',
        task: '将你的双手泡在冰水中15秒。然后摆出下流的姿势，玩弄自己的乳头的同时寸止至少一次。整个过程中你须保持面无表情且不能发出任何声音。',
      },
      {
        name: '冰火两重天',
        task: '在你的后庭中塞入一小块冰块，然后注入热过的润滑液，插入一根在热水中泡过的自慰棒并以 100bpm 的速度将冰块融化。整个过程你需要保持微笑且不能发出声音。',
      },
    ],
    ult: {
      name: '温暖渴求',
      desc: '不死者们一直处于饥饿之中。她们能轻易地爆发出力量以榨取敌人温暖的精液。如不是受恶魔领主的新规限制，血液通常是更好的选择。',
      task: '当技能发动时，在接下来的3个回合内，你所有的bpm増加30且你所造成的伤害増加2点。若你未能在技能结束之前饮下或被注入精液，则受到5点伤害。',
    },
  },
  'corrupted': {
    camp: 2,
    name: '人类: 极恶堕者',
    hp: 10,
    atk: 3,
    desc: '转生成为了一个普通的人类冒险家......但是你身边环绕着的黑雾是什么？你能听到恶魔领主在不知道哪里的地方咯咯地笑着，你的皮肤颜色变深，头发褪色，所有的穴都开始发痒。你现在堕落者的一员了，她们是那些接受了慷概的恶魔领主的魔力人们。你的余生将永远淫靡。',
    clothes: {
      name: '碧池打扮',
      desc: '堕落者们都将自己打得尽可能的色槽。她们用打扮来吸引引受害者们，以此来传播腐化。',
      task: '你需要穿上显眼亮丽的迷你比基尼、吊带袜、项圈和腿环。给自己化个美美的妆。',
    },
    passive_skill: [
      {
        name: '恶堕符文',
        desc: '堕落者内心淫荡的想法都会浮现于她们的皮肤之上。这使得她们无法向别人掩盖自己内心那极度的欲望。',
        task: '你每前进一格，都需要在你身体的某处画上一个下流的标记。标记添加完成后你必须在镜前寸止一次。',
      },
      {
        name: '极乐飞升',
        desc: '你能感到你的理智正在一点点被那些下流的想法和性欲所吞噬。恶魔领主对你施加了一个永久的诅咒使你无法摆脱发情状态。你的皮肤也因无法消散的欲望而变成了深色。',
        task: '你的所有任务的持续时长都增加2分钟。若任务内容没有要求你寸止，你也必须在每个任务期间寸止至少一次（如果你的手没有被束缚的话）。',
      },
    ],
    active_skill: [
      {
        name: '深渊巨穴',
        task: '你需要用手指扩张你的后庭来攻击。用两只手的手指扩张后庭直到它微微张开。然后用四根手指后庭自慰。期间寸止至少ー次。',
      },
      {
        name: '急不可耐',
        task: '跪在地上或床上，然后趴下身子，把你的后穴暴露给敌人，并且寸止至少ー次。当你寸止时，用最大的声音呻吟，求你的敌人赶紧操进你的肉穴。',
      },
      {
        name: '浴火焚身',
        task: '骑在一根大号自慰棒上面的同时，给另一根自慰棒大声地口交，期间用 180bpm 的速度寸止至少一次。想象你正在恳求你的敌人用真家伙干死你。最后一次寸止结束后，在你的脸上浇上 50mL精液。',
      },
    ],
    ult: {
      name: '理性蒸发',
      desc: '黑雾将移除被感染的墜落者们内心仅存的人性，并且将她们转変为极度发情的状态。这使得她们成为了暗影阵营中性爱战斗力最高的种族之一。',
      task: '当技能发动时，你的下一次攻击为<span class="color_useful">[有效]</span>且伤害翻倍。你的下下次攻击为<span class="color_key">[会心]</span>且造三倍基础攻击カ的伤害。每当你发动上述攻击时，你失去2点生命值。若使用此技能将敌人打败则回复你所有的生命值。',
    },
  },
  'robot': {
    camp: 2,
    name: '？？？',
    hp: 10,
    atk: 3,
    desc: '你不知道你自已被转生成了什么种族，有可能是服待于深邃者的自动机器人。你化身为黑暗的代理人，全身被无法拆除的黑色堕者制服包裹。冥冥黑暗之中，一个声音对你下达了命令。你除了听从命令，以及成为这套服装的宿主之外，什么也不能做。',
    clothes: {
      name: '乳胶衣',
      desc: '你身着一件<span class="color_bad">不可拆卸的</span>乳胶衣。它似乎可以凭空变出BDSM装备和性爱玩具出来。它同时也紧紧地贴着你的身体，你的触觉被极度强化，即使仅仅是抚模你的身体也有可能让你绝顶。',
      task: '你需要穿着一件紧身乳胶衣。你可以在其之上覆蓋其他衣服，只要乳胶衣紧贴你的身体。',
    },
    passive_skill: [
      {
        name: '自适应服装',
        desc: '你的服装会自动检测宿主的身体以及周围的环境以适合任何情况。当检测到附近有敌人的阴茎时，你的口球会自动变成强制开口器。',
        task: '在所有任务中你都被强制要求佩戴口球、脚链和手结（注意不要让自己无法逃脱）。在所有口交任务中，你都被要求佩戴强制开口器。',
      },
      {
        name: '感官缺失',
        desc: '当你的服装检测到宿主正在承受快感时，它会自动覆盖宿主的眼睛，使其陷入完全的黑暗。服装通过这种方式进一步地强化宿主的快感。',
        task: '当进行不需要视觉的任务时，你必须佩戴眼罩或者其他能完全遮蔽你视野的配件。',
      },
    ],
    active_skill: [
      {
        name: '自动防御措施',
        task: '在你的后庭塞入一个震动道具，并用其他的震动道具使自己寸止至少一次。',
      },
      {
        name: '过热冷却协议',
        task: '躺下并将双腿紧紧绑在一起，然后将你的双手充分润滑，并在 180bpm 的速度下寸止至少一次。当你寸止时，不断地挺动你的腰部，假装自己绝顶。',
      },
      {
        name: '模式: 侍奉',
        task: '将一根自慰棒插入你的后庭并固定，佩戴强制开口器，然后将另一根带有吸盘的自棒吸在墙上的随机位置。随后转圈以掉自慰棒的位置。将你的手简单固定在身后，用你的口穴找到自慰棒的位置后以 60bpm 的速度进行口交。',
      },
    ],
    ult: {
      name: '模式: 自主行动',
      desc: '该未知种族的特性之一。在紧急精况下，她们可以脫下大多数的用于限制她们的装备来发动更为强力的攻击。',
      task: '当技能发动时，你可以脱下你身上的BDSM装备5分钟。你的生命值回复5点，并且你下一回合可以投两次攻击骰子并攻击两次。但是三个回合内，所有的bpm需要増加40。',
    },
  },
};

window['$'] = document.querySelector.bind(document);
window['$$'] = document.querySelectorAll.bind(document);

String.prototype.vanilla_split = String.prototype.split;
String.prototype.split = function(separator, limit) {
  // 如果没有提供separator，使用原生split
  if (separator === undefined) {
    return this.vanilla_split();
  }
  
  // 如果没有提供limit或limit为0，使用原生split
  if (limit === undefined || limit < 0) {
    return this.vanilla_split(separator);
  }
  if (limit === 0) return [this.toString()];
  
  const result = [];
  let str = this.toString();
  let count = 0;
  
  // 处理separator为空字符串的情况
  if (separator === '') {
    const chars = str.split('');
    return chars.slice(0, limit).concat(chars.slice(limit).join('') || []).filter(s => s !== '');
  }
  
  // 处理正则表达式separator
  if (separator instanceof RegExp) {
    const parts = [];
    let lastIndex = 0;
    let match;
    const regex = new RegExp(separator.source, separator.flags.includes('g') ? separator.flags : separator.flags + 'g');
    
    while ((match = regex.exec(str)) !== null && count < limit) {
      parts.push(str.slice(lastIndex, match.index));
      lastIndex = regex.lastIndex || match.index + match[0].length;
      count++;
      if (!regex.global) break;
    }
    
    if (lastIndex < str.length) {
      parts.push(str.slice(lastIndex));
    }
    
    return parts;
  }
  
  // 处理字符串separator
  let searchIndex = 0;
  
  while (count < limit) {
    const index = str.indexOf(separator, searchIndex);
    
    if (index === -1) {
      // 没有更多的分隔符了
      result.push(str.slice(searchIndex));
      break;
    }
    
    result.push(str.slice(searchIndex, index));
    searchIndex = index + separator.length;
    count++;
    
    if (count === limit) {
      // 达到limit，剩余部分作为最后一个元素
      result.push(str.slice(searchIndex));
    }
  }
  
  // 如果字符串为空或只有分隔符，确保返回正确结果
  if (result.length === 0) {
    result.push(str);
  }
  
  return result;
};

function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
    || (window.innerWidth <= 768);
}
    
const getValue = (k) => {
  return window.localStorage.getItem(k);
}
const setValue = (k, v) => {
  window.localStorage.setItem(k, v);
}

window.addEventListener('error', function(e) {
  const err = e.error || e.message || e;
  if (err == undefined || e instanceof Event) return;
  const msg = `${err}, at ${e.filename}:${e.lineno}:${e.colno}, ${JSON.stringify(e.cause)}`;
  console.error(msg);
  alert(msg);
}, true);


function* range(start, end, step = 1) {
  if (step === 0) {
    throw new RangeError('The step of the range cannot be 0')
  }
  if (end === undefined) {
    end = start
    start = 0
  }
  if (typeof start !== 'number' || typeof end !== 'number' || typeof step !== 'number') {
    throw new RangeError('Only numbers are accepted as arguments')
  }
  if (step > 0) {
    while (start < end) {
      yield start
      start += step
    }
  } else {
    while (start > end) {
      yield start
      start += step
    }
  }
}

const isNumber = s => Object.prototype.toString.call(s) === "[object Number]";
const isString = s => Object.prototype.toString.call(s) === "[object String]";
const isArrayLike = s => s != null && typeof s[Symbol.iterator] === 'function';
function formatDateTime(d) {
  if (d < 9999999999) d *= 1000;
  const formatter = new Intl.DateTimeFormat("zh-CN", {
    timeZone: "Asia/Shanghai",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
  })
  return formatter.format(d).replaceAll('/', '-');
}
function formatDateTimeLess(d) {
  const t = formatDateTime(d)
  return t.slice(t.indexOf('-') + 1, t.lastIndexOf(':'))
}
function formatTime(t) {
  let s = Math.floor(t % 60);
  if (s < 10) s = '0' + s;
  let m = Math.floor(t / 60 % 60);
  if (m < 10) m = '0' + m;
  let h = Math.floor(t / 3600 % 24);
  if (h < 10) h = '0' + h;
  let d = Math.floor(t / 86400);
  if (d < 10) d = '0' + d;
  
  if (d > 0) return `${d}d${h}:${m}:${s}`
  if (h > 0) return `${h}:${m}:${s}`;
  return `${m}:${s}`;
}
function formatTime2(t) {
  let s = Math.floor(t % 60);
  let m = Math.floor(t / 60 % 60);
  let h = Math.floor(t / 3600 % 24);
  let d = Math.floor(t / 86400);
  if (d > 0) {
    if (h > 0) return `${d}d${h}h`;
    if (m > 0) return `${d}d${m}m`;
    if (s > 0) return `${d}d${s}s`;
    return `${d}d`;
  }
  if (h > 0) {
    if (m > 0) return `${h}h${m}m`;
    if (s > 0) return `${h}h${s}s`
    return `${h}h`;
  }
  if (m > 0) {
    if (s > 0) return `${m}m${s}s`;
    return `${m}m`;
  }
  if (s > 0) return `${s}s`;
  return '0';
}
function formatTime3(t) {
  return formatTime2(t).replace('d', '天').replace('h', '小时').replace('m', '分钟').replace('s', '秒');
}

/**
 * 解析 html 字符串
 */
const parseHTML = (html) => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');
  return [...doc.body.children];
}

/**
 * 创建 Element
 * @param {String} tagName 
 * @param {Object} options 
 * @param {function} func 
 * @returns {SVGElement | HTMLElement}
 */
function tag(tagName, options, func) {
  options = options || {};
  var svgTags = ['svg', 'g', 'path', 'filter', 'animate', 'marker', 'line', 'polyline', 'rect', 'circle', 'ellipse', 'polygon'];
  let newElement;
  if (svgTags.indexOf(tagName) >= 0) {
    newElement = document.createElementNS("http://www.w3.org/2000/svg", tagName);
  } else {
    newElement = document.createElement(tagName);
  }
  if (options.id) newElement.id = options.id;
  if (options.class) {
    if (!Array.isArray(options.class)) options.class = options.class.split(' ');
    for (const e of options.class) {
      if (e) newElement.classList.add(e);
    }
  }
  if (options.innerHTML) newElement.innerHTML = options.innerHTML;
  else if (options.innerText) newElement.innerText = options.innerText;
  if (options.children) {
    if (!isArrayLike(options.children)) options.children = [options.children];
    for (const e of options.children) {
      if (isString(e) || isNumber(e)) e = document.createTextNode(e);
      if (e !== undefined && e !== null) newElement.appendChild(e);
    }
  }
  if (options.style) newElement.style.cssText = options.style
  if (options.attrs) {
    for (const [k, v] of Object.entries(options.attrs)) {
      newElement.setAttribute(k, v)
    }
  }
  func && func(newElement)
  return newElement;
}

const getPassiveSkill = (race_key, skill_index, effect) => {
  const r = race_info[race_key];
  const skill = r.passive_skill[skill_index];
  return tag('div', {
    class: 'tooltip color_passive',
    children: [
      tag('span', {
        innerText: skill.name,
      }),
      tag('div', {
        class: 'tooltip-box',
        innerHTML: `<div class="image_box"><img src="/static/images/race_${race_key}_passive_skill${skill_index+1}.jpg"></div><p>${skill.desc}</p><br><p class="color_task">${skill.task}</p>${effect ? `<br><div class="p">当前效果: ${effect}</div>` : ''}`
      })
    ]
  });
}

const getItem = (item_key, amount = 1) => {
  const item = items[item_key];
  let icon = item.icon;
  let background = item.background;
  if (item_key == 'coin') {
    if (amount >= 30) {
      icon = 'coin3';
    } else if (amount >= 20) {
      icon = 'coin2';
    }
  }
  let use = item.use.map(i => `<div>${i.name}: ${i.effect}</div><p class="color_task">${i.task}</p>`).join('<br>');
  if (use) use += '<br>';
  return tag('div', {
    class: 'item tooltip',
    innerHTML: `<div class="item_icon ${background ? `item_${background}` : ''}"><img src="/static/images/icon_${icon}.png"></div><span class="${item.color ? `color_${item.color}` : ''}"> ${item.name}x${amount}</span><div class="tooltip-box">${item.caption ? `<p class="color_npc">${item.caption}</p><br>` : ''}${item.desc.split('\n').map(i => `<p>${i}</p>`).join('')}${use}</div>`,
  });
}

class Base64 {
  /**
   * 代码来自https://github.com/haochuan9421/base64-pro/
   */
  _lookup;
  _revLookup;
  _encodeChunkSize = 16383;
  constructor() {
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    this._lookup = [...alphabet].filter((char, i, arr) => arr.indexOf(char) === i && char.charCodeAt(0) < 128);
    this._revLookup = this._lookup.reduce(
      (map, char, i) => {
        map[char.charCodeAt(0)] = i;
        return map;
      },
      { 43: 62, 47: 63, 45: 62, 95: 63 }
    );
  }
  
  bufferToBase64(value, padding) {
    let arrayBuffer; // 底层的二进制数据
    let byteOffset; // 开始编码的位置
    let totalBytes; // 需要编码的字节总数
    if (ArrayBuffer.isView(value)) {
      arrayBuffer = value.buffer;
      byteOffset = value.byteOffset;
      totalBytes = value.byteLength;
    } else if (value instanceof ArrayBuffer) {
      arrayBuffer = value;
      byteOffset = 0;
      totalBytes = value.byteLength;
    } else {
      throw new Error("encode value can only be arrayBuffer or typedArray or dataView");
    }

    // 3个字节为一组进行处理，多出来的1个或2个字节最后单独处理
    const extraBytes = totalBytes % 3;
    const unit3Bytes = totalBytes - extraBytes;
    // 创建 Uint8Array 视图用于读取字节内容
    const view = new Uint8Array(arrayBuffer, byteOffset, totalBytes);

    // 字符串频繁拼接会比较慢，所以先分块保存，最后再一次性 join 成一个完整的字符串返回
    let chunks = [];
    for (let i = 0; i < unit3Bytes; i += this._encodeChunkSize) {
      let chunk = [];
      for (let j = i, chunkEnd = Math.min(unit3Bytes, i + this._encodeChunkSize); j < chunkEnd; j += 3) {
        // 把三个字节拼接成一个完整的 24 bit 数字
        const $24bitsNum = (view[j] << 16) | (view[j + 1] << 8) | view[j + 2];
        // 以 6 bit 为一个单元进行读取
        chunk.push(
          this._lookup[$24bitsNum >> 18] +
            this._lookup[($24bitsNum >> 12) & 0b111111] + // "& 0b111111" 是为了只保留最后面的6个字节
            this._lookup[($24bitsNum >> 6) & 0b111111] +
            this._lookup[$24bitsNum & 0b111111]
        );
      }
      chunks.push(chunk.join(""));
    }
    // 处理多出来的1个或2个字节
    if (extraBytes === 1) {
      const $8bitsNum = view[totalBytes - 1];
      chunks.push(this._lookup[$8bitsNum >> 2]);
      chunks.push(this._lookup[($8bitsNum << 4) & 0b111111]);
      padding && chunks.push("==");
    } else if (extraBytes === 2) {
      const $16bitsNum = (view[totalBytes - 2] << 8) | view[totalBytes - 1];
      chunks.push(this._lookup[$16bitsNum >> 10]);
      chunks.push(this._lookup[($16bitsNum >> 4) & 0b111111]);
      chunks.push(this._lookup[($16bitsNum << 2) & 0b111111]);
      padding && chunks.push("=");
    }

    return chunks.join("");
  }
  
  base64ToBuffer(base64Str) {
    if (typeof base64Str !== "string") {
      throw new Error("the first argument must be string");
    }
    // 去除尾部的 padding
    base64Str = base64Str.replace(/==?$/, "");
    
    // 4 个字符为一组进行处理，多出来的2个或3个字符最后单独处理
    let totalChars = base64Str.length;
    const extraChars = totalChars % 4;
    const unit4Chars = totalChars - extraChars;
    // 创建 arrayBuffer，每4个字符需要3个字节，如果最后多出来2个字符额外需要1个字节，如果最后多出来3个字符额外需要2个字节
    const arrayBuffer = new ArrayBuffer((unit4Chars / 4) * 3 + (extraChars === 0 ? 0 : extraChars - 1));
    // 创建 DataView 视图用于修改字节内容
    const view = new Uint8Array(arrayBuffer);

    let byteOffset = 0;
    for (let i = 0; i < unit4Chars; i += 4) {
      // 把4个字符对应的 code pointer 还原成3字节的数字
      const $24bitsNum =
        (this._revLookup[base64Str.charCodeAt(i)] << 18) |
        (this._revLookup[base64Str.charCodeAt(i + 1)] << 12) |
        (this._revLookup[base64Str.charCodeAt(i + 2)] << 6) |
        this._revLookup[base64Str.charCodeAt(i + 3)];

      // 以 8 bit 为一个单元修改 arrayBuffer 3次
      view[byteOffset++] = $24bitsNum >>> 16;
      view[byteOffset++] = ($24bitsNum >>> 8) & 0b11111111;
      view[byteOffset++] = $24bitsNum & 0b11111111;
    }
    
    // 处理多出来的2个或3个字符
    if (extraChars === 2) {
      const $8bitNum = (this._revLookup[base64Str.charCodeAt(totalChars - 2)] << 2) | (this._revLookup[base64Str.charCodeAt(totalChars - 1)] >>> 4);
      view[byteOffset++] = $8bitNum;
    } else if (extraChars === 3) {
      const $16bitNum =
        (this._revLookup[base64Str.charCodeAt(totalChars - 3)] << 10) |
        (this._revLookup[base64Str.charCodeAt(totalChars - 2)] << 4) |
        (this._revLookup[base64Str.charCodeAt(totalChars - 1)] >> 2);
      view[byteOffset++] = $16bitNum >>> 8;
      view[byteOffset++] = $16bitNum & 0b11111111;
    }
    return arrayBuffer;
  }
  
  encode(str) {
    const encoder = new TextEncoder();
    let buffer = encoder.encode(str);
    return this.bufferToBase64(buffer);
  }
  
  decode(str) {
    const decoder = new TextDecoder("utf-8");
    let buffer = this.base64ToBuffer(str)
    if (buffer === false) return false;
    return decoder.decode(buffer);
  }
}
let b64 = new Base64();

const gz_encode = function (s) {
  return b64.bufferToBase64(pako.gzip(s));
}
const gz_decode = function (s) {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(pako.ungzip(b64.base64ToBuffer(s)));
}

const gz64_encode = function (s) {
  const encoder = new TextEncoder();
  let buffer = encoder.encode(s);
  if (buffer.length > 140) {
    return gz_encode(s)
  }
  return b64.bufferToBase64(buffer);
}

const gz64_decode = function (s) {
  if (s.startsWith('H4sI')) {
    return gz_decode(s)
  }
  return b64.decode(s)
}

const copyToClipboard = (text) => {
  let nav = navigator || window.navigator;
  if (MoeApp.initData == '' && nav && nav.clipboard && nav.clipboard.writeText) {
    nav.clipboard.writeText(text);
    return
  }
  const tempInput = document.createElement("textarea");
  tempInput.value = text;
  let t = $('dialog[open]');
  if (!t) t = document.body;
  t.appendChild(tempInput);
  tempInput.select();
  document.execCommand("copy");
  t.removeChild(tempInput);
}

/**
 * 下载文件
 */
const downloadFile = (url, filename) => {
  if (!filename) filename = `${Date.now()}.png`;
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
};



/**
 * 调整提示框位置以避免超出视口
 */
function adjustTooltipPosition(tooltip) {
  const tooltipBox = tooltip.querySelector('.tooltip-box');
  // 重置之前的调整类
  tooltipBox.classList.remove('adjust-left', 'adjust-right', 'show-below');
  
  // 获取元素位置信息
  const triggerRect = tooltip.getBoundingClientRect();
  const tooltipRect = tooltipBox.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
  
  // 检查是否超出左边界
  if (tooltipRect.left < 10) {
    tooltipBox.classList.add('adjust-left');
  }
  
  // 检查是否超出右边界
  else if (tooltipRect.right > viewportWidth - 10) {
    tooltipBox.classList.add('adjust-right');
  }
  
  // 检查是否超出顶部（考虑滚动）
  if (triggerRect.top - scrollTop < tooltipRect.height + 20) {
    tooltipBox.classList.add('show-below');
  }
}

/**
 * 显示提示框
 */
function showTooltip(tooltip) {
  const tooltipBox = tooltip.querySelector('.tooltip-box');
  if (tooltipBox) {
    // 调整位置
    adjustTooltipPosition(tooltip, tooltipBox);
    tooltip.classList.add('show');
    const t = tooltip.parentElement.querySelectorAll('.tooltip');
    if (t) t.forEach(i => i.style.zIndex = 1);
  }
}

// 隐藏提示框
function hideTooltip() {
  const tooltip = $('.tooltip.show');
  if (tooltip) {
    tooltip.classList.remove('show');
    const t = tooltip.parentElement.querySelectorAll('.tooltip');
    if (t) t.forEach(i => i.style.zIndex = '');
  }
}

/**
 * 鼠标进入
 */
document.addEventListener('mouseenter', (e) => {
  if (e.target.closest && (tooltip = e.target.closest('.tooltip'))) {
    showTooltip(tooltip);
  }
}, true);
/**
 * 鼠标离开
 */
document.addEventListener('mouseleave', (e) => {
  if (e.target.closest('.tooltip')) {
    hideTooltip();
  }
}, true);

/**
 * 滚动时调整已显示的提示框位置
 */
document.addEventListener('scroll', function() {
  const tooltip = $('.tooltip.show');
  if (tooltip) adjustTooltipPosition(tooltip);
}, true);

/** 
 * 点击事件
 */
document.addEventListener('click', (e) => {
  let tooltip;
  if (tooltip = e.target.closest('.tooltip')) {
    showTooltip(tooltip);
    return;
  }
  hideTooltip();
});
document.addEventListener('click', (e) => {
  switch (true) {
    // 掷骰子
    case !!e.target.closest('.dice'):
      if (e.target.classList.contains('disabled') || e.target.classList.contains('disabled_dice')) return;
      const dice = e.target.closest('.dice');
      const sides = parseInt(dice.getAttribute('data-sides'))
      if (dice.rolling) return;
      dice.rolling = true;
      let timer = setInterval(() => {
        const count = Math.floor(Math.random() * sides) + 1;
        if (sides > 6) {
          dice.innerText = count;
        } else {
          dice.classList.remove('d1', 'd2', 'd3', 'd4', 'd5', 'd6');
          dice.classList.add('d' + count);
        }
      }, 100);
      
      const result = Math.floor(Math.random() * sides) + 1;
      const duration = 1500 + Math.random() * 500;
      setTimeout(() => {
        clearInterval(timer);
        let event = new CustomEvent('dice', {
          bubbles: true,
          detail: { dice: result },
        });
        e.target.dispatchEvent(event);
        e.target.setAttribute('data-dice', result)
  
        if (sides > 6) {
          dice.innerText = result;
        } else {dice.classList.remove('d1', 'd2', 'd3', 'd4', 'd5', 'd6');
          dice.classList.add('d' + result);
        } 
        dice.rolling = false;
      }, duration);
      break
  }
})

/**
 * 地图控制器类
 * @class MapController
 * @description 管理地图的移动和缩放功能
 */
class MapController {
  constructor() {
    /** @type {HTMLElement} 地图容器元素 */
    this.container = $('.map');
    this.content = $('.map .map-content')
    /** @type {HTMLImageElement} 地图图片元素 */
    this.image = $('.map .map-image');
    /** @type {HTMLElement} 标记层元素 */
    this.markersLayer = $('.map .map-markers');
    /** @type {HTMLElement} 缩放信息显示元素 */
    this.zoomInfo = $('.map .zoom-info');
    
    /** @type {Array} 标记数组 */
    this.markers = [];
    /** @type {number} 当前缩放比例 */
    this.scale = 1;
    /** @type {number} 最小缩放比例 */
    this.minScale = 1;
    /** @type {number} 最大缩放比例 */
    this.maxScale = 3;
    /** @type {number} 缩放速度 */
    this.zoomSpeed = 0.1;
    
    /** @type {number} X轴位置 */
    this.posX = 0;
    /** @type {number} Y轴位置 */
    this.posY = 0;
    
    /** @type {boolean} 是否正在拖动 */
    this.isDragging = false;
    /** @type {number} 拖动起始X坐标 */
    this.startX = 0;
    /** @type {number} 拖动起始Y坐标 */
    this.startY = 0;
    /** @type {number} 拖动起始时的X位置 */
    this.startPosX = 0;
    /** @type {number} 拖动起始时的Y位置 */
    this.startPosY = 0;
    
    /** @type {number} 双指触摸的初始距离 */
    this.initialPinchDistance = 0;
    /** @type {number} 双指触摸的初始缩放比例 */
    this.initialScale = 1;
    
    /** @type {number|null} 缩放信息隐藏定时器 */
    this.zoomInfoTimer = null;
    
    /** @type {number|null} 双击检测定时器 */
    this.tapTimeout = null;
    /** @type {number} 上次点击时间 */
    this.lastTapTime = 0;
    /** @type {number} 双击时间阈值（毫秒） */
    this.doubleTapDelay = 300;
    
    let x;
    if ((x = this.container.getAttribute('data-scale')) && (x = parseInt(x))) {
      this.scale = x;
      let centerX = 0;
      let centerY = 0;
      if ((x = this.container.getAttribute('data-centerX')) && (x = parseFloat(x))) centerX = x / 100;
      if ((x = this.container.getAttribute('data-centerY')) && (x = parseFloat(x))) centerY = x / 100;

      const rect = this.container.getBoundingClientRect();
      this.posX = -centerX * rect.width;
      this.posY = -centerY * rect.height;
      this.animateTransform();
    }
    
    this.init();
  }

  /**
   * 初始化事件监听器
   * @description 绑定鼠标和触摸事件
   */
  init() {
    // 鼠标事件
    this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
    document.addEventListener('mousemove', this.handleMouseMove.bind(this));
    document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    this.container.addEventListener('wheel', this.handleWheel.bind(this));
    
    // 双击事件
    this.container.addEventListener('dblclick', this.handleDoubleClick.bind(this));
    
    // 触摸事件
    this.container.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.container.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.container.addEventListener('touchend', this.handleTouchEnd.bind(this));
    
    // 阻止右键菜单
    this.container.addEventListener('contextmenu', e => e.preventDefault());
    
    // 按钮
    $('.map-box .zoomIn').addEventListener('click', this.zoomIn.bind(this));
    $('.map-box .zoomOut').addEventListener('click', this.zoomOut.bind(this));
  }

  /**
   * 处理鼠标按下事件
   * @param {MouseEvent} e - 鼠标事件对象
   */
  handleMouseDown(e) {
    this.isDragging = true;
    this.container.classList.add('grabbing');
    this.startX = e.clientX;
    this.startY = e.clientY;
    this.startPosX = this.posX;
    this.startPosY = this.posY;
  }

  /**
   * 处理鼠标移动事件
   * @param {MouseEvent} e - 鼠标事件对象
   */
  handleMouseMove(e) {
    if (!this.isDragging) return;
    
    const deltaX = e.clientX - this.startX;
    const deltaY = e.clientY - this.startY;
    
    this.posX = this.startPosX + deltaX;
    this.posY = this.startPosY + deltaY;
    
    this.updateTransform();
  }

  /**
   * 处理鼠标释放事件
   * @param {MouseEvent} e - 鼠标事件对象
   */
  handleMouseUp(e) {
    this.isDragging = false;
    this.container.classList.remove('grabbing');
  }

  /**
   * 处理鼠标滚轮事件
   * @param {WheelEvent} e - 滚轮事件对象
   */
  handleWheel(e) {
    e.preventDefault();
    
    const delta = e.deltaY > 0 ? -this.zoomSpeed : this.zoomSpeed;
    const oldScale = this.scale;
    const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale + delta));
    
    if (newScale !== this.scale) {
      // 计算鼠标位置相对于容器的坐标
      const rect = this.container.getBoundingClientRect();
      const x = e.clientX - rect.left - rect.width / 2;
      const y = e.clientY - rect.top - rect.height / 2;
      
      // 调整位置以保持鼠标下的点不动
      const scaleRatio = newScale / oldScale;
      this.posX = x - (x - this.posX) * scaleRatio;
      this.posY = y - (y - this.posY) * scaleRatio;
      
      this.scale = newScale;
      this.updateTransform();
    }
  }

  /**
   * 处理触摸开始事件
   * @param {TouchEvent} e - 触摸事件对象
   */
  handleTouchStart(e) {
    // try{e.preventDefault();}catch(err){};
    
    if (e.touches.length === 1) {
      // 单指触摸 - 拖动
      this.isDragging = true;
      this.startX = e.touches[0].clientX;
      this.startY = e.touches[0].clientY;
      this.startPosX = this.posX;
      this.startPosY = this.posY;
    } else if (e.touches.length === 2) {
      // 双指触摸 - 缩放
      this.isDragging = false;
      this.initialPinchDistance = this.getPinchDistance(e.touches);
      this.initialScale = this.scale;
    }
  }

  /**
   * 处理触摸移动事件
   * @param {TouchEvent} e - 触摸事件对象
   */
  handleTouchMove(e) {
    e.preventDefault();
    
    if (e.touches.length === 1 && this.isDragging) {
      // 单指移动
      const deltaX = e.touches[0].clientX - this.startX;
      const deltaY = e.touches[0].clientY - this.startY;
      
      this.posX = this.startPosX + deltaX;
      this.posY = this.startPosY + deltaY;
      
      this.updateTransform();
    } else if (e.touches.length === 2) {
      // 双指缩放
      const currentDistance = this.getPinchDistance(e.touches);
      const scale = currentDistance / this.initialPinchDistance;
      
      this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.initialScale * scale));
      this.updateTransform();
    }
  }

  /**
   * 处理触摸结束事件
   * @param {TouchEvent} e - 触摸事件对象
   */
  handleTouchEnd(e) {
    if (e.touches.length === 0) {
      this.isDragging = false;
      // 检测双击
      const currentTime = Date.now();
      const tapLength = currentTime - this.lastTapTime;
      
      if (tapLength >= this.doubleTapDelay || tapLength <= 0) {
        this.lastTapTime = currentTime;
      } else {
        // 双击检测成功
        e.preventDefault();
        
        // 获取最后一个触摸点的位置
        const touch = e.changedTouches[0];
        const rect = this.container.getBoundingClientRect();
        const x = touch.clientX - rect.left - rect.width / 2;
        const y = touch.clientY - rect.top - rect.height / 2;
        
        this.toggleZoom(x, y);
        this.lastTapTime = 0; // 重置时间
      }
    } else if (e.touches.length === 1) {
      // 从双指变为单指，重新初始化拖动
      this.isDragging = true;
      this.startX = e.touches[0].clientX;
      this.startY = e.touches[0].clientY;
      this.startPosX = this.posX;
      this.startPosY = this.posY;
    }
  }

  /**
   * 计算两个触摸点之间的距离
   * @param {TouchList} touches - 触摸点列表
   * @returns {number} 两点之间的距离
   */
  getPinchDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  /**
   * 处理双击事件
   * @param {MouseEvent} e - 鼠标事件对象
   */
  handleDoubleClick(e) {
    e.preventDefault();
    
    // 获取点击位置相对于容器中心的坐标
    const rect = this.container.getBoundingClientRect();
    const x = e.clientX - rect.left - rect.width / 2;
    const y = e.clientY - rect.top - rect.height / 2;
    
    this.toggleZoom(x, y);
  }
  
  /**
   * 切换缩放状态
   * @param {number} centerX - 缩放中心X坐标
   * @param {number} centerY - 缩放中心Y坐标
   */
  toggleZoom(centerX = 0, centerY = 0) {
    const targetScale = this.scale === 1 ? 2 : 1;
    const scaleRatio = targetScale / this.scale;
    
    // 调整位置以保持点击位置不动
    if (targetScale === 2) {
      this.posX = centerX - (centerX - this.posX) * scaleRatio;
      this.posY = centerY - (centerY - this.posY) * scaleRatio;
    } else {
      // 恢复到100%时居中
      this.posX = 0;
      this.posY = 0;
    }
    
    this.scale = targetScale;
    this.animateTransform();
  }

  /**
   * 限制拖动范围，防止出现空白
   * @description 根据当前缩放比例计算并限制位置
   */
  limitPosition() {
    const containerRect = this.container.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;
    
    // 计算缩放后的图片尺寸
    const scaledWidth = containerWidth * this.scale;
    const scaledHeight = containerHeight * this.scale;
    
    // 计算最大可移动距离
    const maxX = Math.max(0, (scaledWidth - containerWidth) / 2);
    const maxY = Math.max(0, (scaledHeight - containerHeight) / 2);
    
    // 限制位置在边界内
    this.posX = Math.max(-maxX, Math.min(maxX, this.posX));
    this.posY = Math.max(-maxY, Math.min(maxY, this.posY));
  }

  /**
   * 更新图片的变换属性
   * @description 应用当前的缩放和位置到图片元素
   */
  updateTransform() {
    this.limitPosition(); // 在更新前限制位置
    this.content.style.transform = `translate(${this.posX}px, ${this.posY}px) scale(${this.scale})`;
    this.zoomInfo.textContent = `${Math.round(this.scale * 100)}%`;
    this.showZoomInfo()
  }
  
  /**
   * 带动画的变换更新
   * @description 平滑过渡缩放和位置变化
   */
  animateTransform() {
    this.content.style.transition = 'transform .3s ease-in-out';
    this.updateTransform();
    
    // 动画结束后移除过渡效果
    setTimeout(() => {
      this.content.style.transition = 'none';
    }, 300);
  }
  
  /**
   * 显示缩放信息并在3秒后自动隐藏
   * @description 显示当前缩放百分比，3秒后淡出
   */
  showZoomInfo() {
    // 清除之前的定时器
    if (this.zoomInfoTimer) {
      clearTimeout(this.zoomInfoTimer);
    }
    
    // 显示缩放信息
    this.zoomInfo.classList.add('show');
    
    // 3秒后隐藏
    this.zoomInfoTimer = setTimeout(() => {
      this.zoomInfo.classList.remove('show');
      this.zoomInfoTimer = null;
    }, 3000);
  }

  /**
   * 放大地图
   * @description 增加缩放比例
   */
  zoomIn() {
    this.scale = Math.min(this.maxScale, this.scale + this.zoomSpeed * 2);
    this.updateTransform();
  }

  /**
   * 缩小地图
   * @description 减少缩放比例
   */
  zoomOut() {
    this.scale = Math.max(this.minScale, this.scale - this.zoomSpeed * 2);
    this.updateTransform();
  }

  /**
   * 重置视图
   * @description 将地图恢复到初始位置和缩放
   */
  resetView() {
    this.scale = 1;
    this.posX = 0;
    this.posY = 0;
    this.updateTransform();
  }
  
  /**
   * 添加地图标记
   * @param {Object} options - 标记选项
   * @param {number} options.x - X坐标（百分比，0-100）
   * @param {number} options.y - Y坐标（百分比，0-100）
   * @param {string} [options.label] - 标记标签
   * @param {string} [options.type] - 标记类型
   * @param {string} [options.id] - 标记ID
   * @param {Function} [options.onClick] - 点击回调
   * @returns {HTMLElement} 标记元素
   */
  addMarker(options) {
    let { 
      x, y, key,
      label = '', 
      type = 'pin', 
      id = Date.now(), 
      onclick,
      width, 
      height,
    } = options;
  
    // 创建标记元素
    const blocks = {
      'battle': '战斗格',
      'random_event': '随机事件格',
    }
    if (type in blocks) {
      label = blocks[type];
      label = `#${key} ` + label;
    }
    
    const marker = document.createElement('div');
    marker.className = 'map-marker' + (label ? ' tooltip': '');
    if (key) {
      id = 'block-' + key;
    }
    marker.id = 'marker-' + id;
    marker.style.left = `${x}%`;
    marker.style.top = `${y}%`;
    switch (type) {
      case 'pin':
        width = 3.34;
        height = 3.34;
        break;
      case 'battle':
      case 'random_event':
        width = 4.1;
        height = 4.1;
        break;
    }
    if (width) {
      if (width != 'auto') width += '%';
      marker.style.width = width;
    }
    if (height) {
      if (height != 'auto') height += '%';
      marker.style.height = height;
    }
    
    // 根据类型创建标记内容
    switch (type) {
      case 'pin':
        marker.innerHTML = `<div class="marker-pin"></div>${label ? `<div class="marker-label">${label}</div>` : ''}`;
        break;
      case 'battle':
      case 'random_event':
        marker.innerHTML = `<div class="marker-${type}"></div><div class="tooltip-box">${label}</div>`;
        break;
      case 'box':
        marker.innerHTML = `<div class="box box15"></div><div class="tooltip-box">${label}</div>`;
        break;
      case 'start':
        marker.innerHTML = `<div class="box box15"><div>开始</div></div><div class="tooltip-box">${label}</div>`;
        break;
      case 'custom':
        marker.innerHTML = options.html || '';
        break;
    }
    
    this.markersLayer.appendChild(marker);
    
    return marker;
  }
}

/**
 * dialog点击
 */
function dialog_close(e) {
  if (e.target.nodeName != 'DIALOG') return;
  e.preventDefault();
  e.target.classList.add('closing');
  setTimeout(() => {
    e.target.classList.remove('closing');
    e.target.close();
  }, 300);
}
document.addEventListener('mousedown', dialog_close);
if (isMobile()) document.addEventListener('touchend', dialog_close);

/**
 * rgb(r,g,b)颜色转十六进制
 */
function rgbToHex(rgb) {
  // 检查rgb或rgba格式
  const match = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.?\d*))?\)$/);
  if (!match) {
    return '';
  }
  // 提取RGB值
  const r = parseInt(match[1]);
  const g = parseInt(match[2]);
  const b = parseInt(match[3]);
  // 转换为十六进制
  const hex = '#' + 
    ((1 << 24) + (r << 16) + (g << 8) + b)
    .toString(16)
    .slice(1);
  return hex;
}
/**
 * 获取Element带颜色文本，注意 Element 需要添加到body中才能获取到 color
 */
const getElementText = (obj) => {
  if (obj == null) return '';
  if (typeof obj[Symbol.iterator] === 'function') {
    return [...obj].map(getElementText).join(' ');
  }
  if (obj.childElementCount > 0) {
    return getElementText(obj.children);
  }
  const color = rgbToHex(window.getComputedStyle(obj).color);
  return `ō${obj.innerText}óǒ${color}ò`;
}
/**
 * getElementText 得到的带颜色文本转 html
 */
const elementText2html = (text) => {
  return text.replaceAll(/\ō(.*?)\ó\ǒ(#.*?)\ò/g, '<span style="color: $2">$1</span>');
}
/**
 * 清除 html标签
 */
const cleanHTML = (text) => {
  return text.replaceAll(/<.*?\>.*?\<\/.*?\>/g, '');
}
/**
 * 裁剪 ElementText
 */
function cutElementText(str, maxLength = 100) {
  let totalLength = 0;
  let result = '';
  let i = 0;
  let flag = false;
  while (i < str.length && totalLength < maxLength) {
    if (str[i] === 'ō' && str.indexOf('óǒ', i) !== -1) {
      const bracketEnd = str.indexOf('óǒ', i);
      const linkEnd = str.indexOf('ò', bracketEnd + 2);
      if (linkEnd === -1) break;
      const content = str.substring(i + 1, bracketEnd);
      const remaining = maxLength - totalLength;
      if (content.length <= remaining) {
        result += str.substring(i, linkEnd + 1);
        totalLength += content.length;
        i = linkEnd + 1;
      } else {
        result += 'ō' + content.substring(0, remaining) + str.substring(bracketEnd, linkEnd + 1);
        totalLength += remaining;
        i = linkEnd + 1;
        flag = true;
        break;
      }
    } else {
      result += str[i];
      totalLength++;
      i++;
    }
  }
  if (flag || totalLength >= maxLength) result += '...';
  return result;
}

class CircularSlider {
  constructor(selector, minValue, maxValue, initValue, formatter) {
    this.container = $(selector);
    this.slider = this.container.querySelector('.circular-slider');
    this.handle = this.container.querySelector('.handle');
    this.progress = this.container.querySelector('.progress');
    this.valueDisplay = this.container.querySelector('.value-number');
    
    const width = this.container.querySelector('.slider-container').clientWidth
    this.centerX = width / 2;
    this.centerY = width / 2;
    this.radius = width / 2 - 15;
    this.minValue = 40;
    if (minValue) this.minValue = minValue;
    this.maxValue = 240;
    if (maxValue) this.maxValue = maxValue;
    this.currentValue = 60;
    if (initValue) this.currentValue = initValue;
    this.isDragging = false;
    this.formatter = formatter;
    
    this.circumference = 2 * Math.PI * (width - 20);
    this.progress.style.strokeDasharray = `${this.circumference} ${this.circumference}`;
    
    this.lastAngle = 0;
    this.totalRotation = 0;
    this.isLocked = false; // 是否锁定在边界
    this.disabled = false;
    this.init();
  }
  get value() {
    return this.currentValue;
  }
  set value(v) {
    this.currentValue = v;
    this.updateSlider(this.currentValue)
  }
  
  init() {
    this.updateSlider(this.currentValue);
    this.lastAngle = this.valueToAngle(this.currentValue);
    
    this.handle.addEventListener('mousedown', this.startDrag.bind(this));
    document.addEventListener('mousemove', this.drag.bind(this));
    document.addEventListener('mouseup', this.endDrag.bind(this));
    
    this.handle.addEventListener('touchstart', this.startDrag.bind(this));
    document.addEventListener('touchmove', this.drag.bind(this));
    document.addEventListener('touchend', this.endDrag.bind(this));
    
    this.slider.addEventListener('click', this.handleClick.bind(this));
  }
  
  startDrag(e) {
    e.preventDefault();
    if (this.disabled) return;
    this.isDragging = true;
    this.isLocked = false;
  }
  
  drag(e) {
    if (this.disabled) return;
    if (!this.isDragging) return;
    
    const rect = this.slider.getBoundingClientRect();
    let clientX, clientY;
    
    if (e.type.includes('touch')) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    const x = clientX - rect.left - this.centerX;
    const y = clientY - rect.top - this.centerY;
    
    let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
    if (angle < 0) angle += 360;
    
    // 限制角度跳变
    angle = this.constrainAngle(angle);
    
    const value = this.angleToValue(angle);
    this.updateSlider(value);
  }
  
  endDrag() {
    this.isDragging = false;
  }
  
  handleClick(e) {
    if (this.disabled) return;
    if (e.target === this.handle) return;
    
    const rect = this.slider.getBoundingClientRect();
    const x = e.clientX - rect.left - this.centerX;
    const y = e.clientY - rect.top - this.centerY;
    
    let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
    if (angle < 0) angle += 360;
    
    // 限制角度跳变
    angle = this.constrainAngle(angle);
    
    const value = this.angleToValue(angle);
    this.updateSlider(value);
  }
  
  constrainAngle(newAngle) {
    // 计算角度差
    let angleDiff = newAngle - this.lastAngle;
    
    // 处理跨越0/360度边界的情况
    if (angleDiff > 180) {
      // 从小角度跳到大角度（逆时针跨越0度）
      angleDiff -= 360;
    } else if (angleDiff < -180) {
      // 从大角度跳到小角度（顺时针跨越360度）
      angleDiff += 360;
    }
    
    // 检测是否试图跨越边界
    const predictedAngle = this.lastAngle + angleDiff;
    
    // 如果预测角度超过360度或小于0度，限制在边界
    if (predictedAngle >= 360) {
      // 停在最大值（360度对应maxValue）
      this.isLocked = true;
      return 359.99; // 接近360但不等于360，避免数值问题
    } else if (predictedAngle < 0) {
      // 停在最小值（0度对应minValue）
      this.isLocked = true;
      return 0;
    }
    
    // 如果已经锁定在边界，检查是否要解锁
    if (this.isLocked) {
      // 如果在最大值边界，只有向减小方向移动才解锁
      if (this.lastAngle > 350 && angleDiff < -10) {
        this.isLocked = false;
      }
      // 如果在最小值边界，只有向增大方向移动才解锁
      else if (this.lastAngle < 10 && angleDiff > 10) {
        this.isLocked = false;
      } else {
        // 保持锁定状态
        return this.lastAngle;
      }
    }
    
    this.lastAngle = newAngle;
    return newAngle;
  }
  
  angleToValue(angle) {
    const range = this.maxValue - this.minValue;
    const value = (angle / 360) * range + this.minValue;
    return Math.round(value);
  }
  
  valueToAngle(value) {
    const range = this.maxValue - this.minValue;
    const angle = ((value - this.minValue) / range) * 360;
    return angle;
  }
  
  updateSlider(value) {
    value = Math.max(this.minValue, Math.min(this.maxValue, value));
    this.currentValue = value;
    const event = new CustomEvent('input', {
      bubbles: true,
      detail: { value: value },
    });
    this.slider.value = value;
    this.slider.dispatchEvent(event);
    
    const angle = this.valueToAngle(value);
    const angleRad = (angle - 90) * (Math.PI / 180);
    
    const handleX = this.centerX + this.radius * Math.cos(angleRad);
    const handleY = this.centerY + this.radius * Math.sin(angleRad);
    
    this.handle.style.left = handleX + 'px';
    this.handle.style.top = handleY + 'px';
    
    const dashOffset = this.circumference - (angle / 360) * this.circumference;
    this.progress.style.strokeDashoffset = dashOffset;
    
    let formatter = Math.round;
    if (this.formatter) formatter = this.formatter;
    this.valueDisplay.textContent = formatter(value);
  }
  
  addEventListener(event_name, func, flag) {
    this.slider.addEventListener(event_name, func, flag);
  }
}

class Timer {
  constructor() {
    this.slider = new CircularSlider('.timer', 30, 1800, 300, formatTime);
    this.isPlaying = false;
    this.timer = null;
    this.value = 30;
    this.audioElement = tag('audio', {
      attrs: {
        src: '/static/audios/clock.wav',
        preload: 'auto',
        loop: '',
      },
    });
    document.body.appendChild(this.audioElement);
    this.init();
  }
  
  init() {
    $('.timer').addEventListener('click', (e) => {
      if (!e.target.closest('.btn')) return;
      let amount = parseInt(e.target.getAttribute('data-amount'));
      if (this.isPlaying)
       amount = amount / this.value * 1770;
      this.adjustValue(amount);
    });
    $('.timer .value-display').addEventListener('touchend', (e) => {
      e.preventDefault();
      this.toggleTimer();
    })
  }
  
  adjustValue(amount) {
    let newValue = parseInt(this.slider.value) + amount;
    newValue = Math.max(30, Math.min(1800, newValue));
    this.slider.value = newValue;
    if (!this.isPlaying) this.value = newValue;
  }
  
  toggleTimer() {
    this.isPlaying = !this.isPlaying;
    this.slider.disabled = this.isPlaying;
    if (this.isPlaying) {
      clearTimeout(this.timer);
      $('.timer').classList.add('playing')
      this.slider.formatter = (value) => {
        const percentage = (value - 30) / 1770;
        return formatTime(percentage * this.value)
      }
      this.value = this.slider.value;
      this.slider.value = 1800;
      this.timer = setInterval(this.intervalTimer.bind(this), 1000);
    } else {
      if (!this.audioElement.paused) this.audioElement.pause();
      $('.timer').classList.remove('playing');
      clearTimeout(this.timer);
      this.slider.formatter = formatTime;
      this.slider.value = this.value;
    }
  }
  
  intervalTimer() {
    this.slider.value -= 1 / this.value * 1770 - 1;
    if (this.slider.value <= 30) this.endTimer();
  }
  
  endTimer() {
    clearTimeout(this.timer);
    this.audioElement.currentTime = 0;
    this.audioElement.play();
  }
}

class Metronome {
  constructor() {
    this.bpmSlider = new CircularSlider('.metronome'); 
    this.bpmValue = document.getElementById('bpmValue');
    this.beatIndicator = document.getElementById('beatIndicator');
    this.beatsPerMeasureSelect = document.getElementById('beatsPerMeasure');
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.isPlaying = false;
    // 当前拍
    this.currentBeat = 0;
    // 当前 bpm
    this.bpm = parseInt(this.bpmSlider.value);
    // 节拍
    this.beatsPerMeasure = 4;
    // 下一拍时间
    this.nextNoteTime = 0.0;
    // 调度器多久检查一次是否需要安排新的节拍
    this.lookahead = 25.0; // 毫秒
    // 提前多长时间将音频事件加入到播放队列
    this.scheduleAheadTime = 0.1; // 秒
    this.timer = null;
    this.init();
  }
  
  init() {
    $('.metronome').addEventListener('click', (e) => {
      if (!e.target.closest('.btn')) return;
      const amount = parseInt(e.target.getAttribute('data-amount'));
      this.adjustBPM(amount);
    });
    this.bpmSlider.addEventListener('input', this.updateBPM.bind(this));
    this.beatsPerMeasureSelect.addEventListener('change', (e) => {
      this.beatsPerMeasure = parseInt(e.target.value);
      this.currentBeat = 0;
    });
    this.beatIndicator.addEventListener('touchend', (e) => {
      e.preventDefault();
      this.toggleMetronome();
    });
  }
  
  /**
   * 开关节拍器
   */
  toggleMetronome() {
    this.isPlaying = !this.isPlaying;
    if (this.isPlaying) {
      this.currentBeat = 0;
      this.nextNoteTime = this.audioContext.currentTime;
      this.scheduler();
    } else {
      clearTimeout(this.timer);
    }
  }
  /**
   * 调度器
   */
  scheduler() {
    while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
      this.scheduleNote(this.currentBeat, this.nextNoteTime);
      this.nextNote();
    }
    this.timer = setTimeout(this.scheduler.bind(this), this.lookahead);
  }
  /**
   * 调度节拍
   */
  scheduleNote(beatNumber, time) {
    this.playNote(time, beatNumber);
    
    // 视觉反馈
    if (time - this.audioContext.currentTime < 0.1) {
      setTimeout(() => {
        this.beatIndicator.classList.add('active');
        setTimeout(() => {
          this.beatIndicator.classList.remove('active');
        }, 100);
      }, (time - this.audioContext.currentTime) * 1000);
    }
  }
  /**
   * 计算下一个节拍时间
   */
  nextNote() {
    const secondsPerBeat = 60.0 / this.bpm;
    this.nextNoteTime += secondsPerBeat;
    
    this.currentBeat++;
    if (this.currentBeat === this.beatsPerMeasure) {
      this.currentBeat = 0;
    }
  }
  
  playNote(time, beatNumber) {
    const osc = this.audioContext.createOscillator();
    const envelope = this.audioContext.createGain();
    osc.connect(envelope);
    envelope.connect(this.audioContext.destination);
    
    // 第一拍音调更高
    if (beatNumber === 0) {
      osc.frequency.value = 1000;
    } else {
      osc.frequency.value = 800;
    }
    
    envelope.gain.setValueAtTime(1, time);
    envelope.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
    
    osc.start(time);
    osc.stop(time + 0.05);
  }
  
  /**
   * 调整BPM
   */
  adjustBPM(amount) {
    let newBPM = parseInt(this.bpmSlider.value) + amount;
    newBPM = Math.max(40, Math.min(240, newBPM));
    this.bpmSlider.value = newBPM;
    console.log(parseInt(this.bpmSlider.value))
    this.updateBPM();
  }
  
  /**
   * 更新BPM显示
   */
  updateBPM() {
    this.bpm = parseInt(this.bpmSlider.value);
    this.bpmValue.textContent = this.bpm;
  }
}